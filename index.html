<!DOCTYPE html>
<html lang="ja">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§¹</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Cleaning Game</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Courier New', monospace;
            user-select: none;
            overflow: hidden;
        }

       /* --- UIå‘¨ã‚Š --- */
        #ui-bar {
            width: 1280px;
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* å·¦ãƒ»ä¸­å¤®ãƒ»å³ ã®3åˆ†å‰² */
            align-items: center;
            margin-bottom: 10px;
            position: relative;
        }

        /* å·¦ã‚¨ãƒªã‚¢ */
        #top-left-info {
            grid-column: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        /* ... (ä¸­ç•¥: #cycle-container ãªã©ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯ãã®ã¾ã¾) ... */

        /* â˜…å¤‰æ›´: ä¸­å¤®ã‚¨ãƒªã‚¢ (çµ±è¨ˆ + é€²è¡Œç‡) */
        #center-panel {
            grid-column: 2;
            display: flex;
            align-items: center;
            gap: 20px; /* ãƒœã‚¿ãƒ³ã¨é€²è¡Œç‡ã®é–“éš” */
        }

        #progress-container {
            /* grid-column: 2; ã‚’å‰Šé™¤ */
            text-align: center;
            font-size: 32px;
            font-weight: bold;
        }

        /* å³ã‚¨ãƒªã‚¢ */
        #right-panel {
            grid-column: 3;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }

        #cycle-container {
            font-size: 24px;
            font-weight: bold;
            font-family: 'Impact', sans-serif;
            letter-spacing: 1px;
        }

        .cycle-text {
            color: #fff;
        }
        .cycle-limit {
            color: #666;
            font-size: 0.8em;
        }

        /* æ•°å­—ãŒå…‰ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes flashAnim {
            0% { color: #fff; text-shadow: none; transform: scale(1); }
            50% { color: #00ff00; text-shadow: 0 0 20px #00ff00, 0 0 40px #fff; transform: scale(1.5); }
            100% { color: #fff; text-shadow: none; transform: scale(1); }
        }
        .flash-active {
            animation: flashAnim 1.0s ease-out forwards;
        }

        #premium-btn {
            background: linear-gradient(135deg, #b8860b, #ffd700);
            color: #000;
            border: 1px solid #fff;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            padding: 5px 15px;
        }
        #premium-btn:hover {
            background: linear-gradient(135deg, #ffd700, #ffec8b);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #ppt-container {
            color: #ffd700;
            font-weight: bold;
            font-size: 18px;
        }

        #progress-container {
            grid-column: 2;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
        }

        #right-panel {
            grid-column: 3;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }

        #money-container {
            font-size: 20px;
            min-width: 150px;
            text-align: right;
            margin-left: 10px;
        }

        button {
            background-color: #333;
            color: #fff;
            border: 1px solid #fff;
            padding: 5px 15px;
            font-family: inherit;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.1s, opacity 0.1s;
        }
        button:hover {
            background-color: #555;
        }
        button:disabled {
            background-color: #222;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
        button:active {
            transform: translateY(1px);
        }

        #settings-btn {
            padding: 5px 10px;
            font-size: 0.9em;
        }

        #hint-box {
            position: absolute;
            border: 2px solid #ff0000;
            box-shadow: 0 0 4px #ff0000, inset 0 0 4px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 5;
            box-sizing: border-box;
        }

        /* --- ã‚²ãƒ¼ãƒ è¡¨ç¤ºã‚¨ãƒªã‚¢ --- */
        #game-container {
            width: 1280px;
            height: 720px;
            border: 1px solid #fff;
            position: relative;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            background-color: #000;
            image-rendering: pixelated; 
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            z-index: 1; 
        }

        #entity-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 2; 
        }

        .robot {
            position: absolute;
            background-color: #ff3333; 
            box-shadow: 0 0 4px #ff0000;
            width: 1px;
            height: 1px;
        }

        /* â˜…è¿½åŠ : ã‚²ãƒ¼ãƒŸãƒ³ã‚°ãƒ­ãƒœãƒƒãƒˆç”¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes rainbow {
            0% { background-color: #ff0000; box-shadow: 0 0 8px #ff0000; }
            15% { background-color: #ff00ff; box-shadow: 0 0 8px #ff00ff; }
            30% { background-color: #0000ff; box-shadow: 0 0 8px #0000ff; }
            45% { background-color: #00ffff; box-shadow: 0 0 8px #00ffff; }
            60% { background-color: #00ff00; box-shadow: 0 0 8px #00ff00; }
            75% { background-color: #ffff00; box-shadow: 0 0 8px #ffff00; }
            100% { background-color: #ff0000; box-shadow: 0 0 8px #ff0000; }
        }
        .robot.gaming {
            animation: rainbow 0.5s linear infinite;
        }

        /* ãƒ—ãƒ©ã‚ºãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        .plasma-beam {
            position: absolute;
            /* å¤‰æ›´: åŸè‰²ã®æ°´è‰²ã‹ã‚‰ã€åŠé€æ˜ã®æ·¡ã„ãƒ–ãƒ«ãƒ¼ã«å¤‰æ›´ */
            background-color: rgba(173, 216, 230, 0.4); 
            
            /* å¤‰æ›´: ã‚®ãƒ©ã‚®ãƒ©ã—ãŸç™ºå…‰(box-shadow)ã‚’å¼±ãã€æŸ”ã‚‰ã‹ãã™ã‚‹ */
            box-shadow: 0 0 4px rgba(173, 216, 230, 0.5), 0 0 8px rgba(255, 255, 255, 0.3);
            
            transform-origin: 0 50%;
            opacity: 1;
            transition: opacity 0.8s ease-out;
            z-index: 5;
            border-radius: 999px;
            
            /* è¿½åŠ : è¼ªéƒ­ã‚’ã¼ã‹ã—ã¦ã•ã‚‰ã«æŸ”ã‚‰ã‹ã */
            filter: blur(1px);
        }

        /* --- ä¸‹éƒ¨æƒ…å ±ã‚¨ãƒªã‚¢ --- */
        #bottom-info {
            width: 1280px;
            height: 30px;
            margin-top: 5px;
            display: flex;
            align-items: center; 
            gap: 20px; 
        }

        #zoom-control-area {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #zoom-indicator {
            color: #0f0;
            font-weight: bold;
            display: none; 
        }

        #reset-zoom-btn {
            padding: 2px 8px;
            font-size: 0.8em;
            background-color: #444;
            border-color: #888;
            display: none; 
        }
        #reset-zoom-btn:hover {
            background-color: #666;
        }

        #save-status {
            color: #aaa;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* --- ãƒ¢ãƒ¼ãƒ€ãƒ« (å…±é€š) --- */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #000;
            border: 2px solid #fff;
            padding: 20px;
            width: 500px;
            height: 500px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            flex-direction: column;
        }
        
        .modal-content {
            flex: 1;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #fff;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .modal-header h2 {
            margin: 0;
        }
        .page-indicator {
            font-size: 1.2em;
            font-weight: bold;
        }

        .modal-footer {
            margin-top: auto; 
            padding-top: 15px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pagination-controls {
            display: flex;
            gap: 10px;
        }
        .pagination-controls button {
            width: 40px;
            padding: 5px 0;
            text-align: center;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #444;
        }
        
        .upgrade-item.purchased {
            border-color: #333;
            color: #999; 
            background-color: #111;
        }
        
        .upgrade-item.next-up {
            border-color: #fff;
            background-color: #000;
        }

        .upgrade-info div:first-child {
            font-weight: bold;
            font-size: 1.1em;
        }
        .upgrade-info div:last-child {
            font-size: 0.8em;
            color: #aaa;
        }
        .upgrade-item.purchased .upgrade-info div:last-child {
            color: #555;
        }

        .status-text {
            font-weight: bold;
            color: #0f0;
            padding: 5px 10px;
        }

        .action-part {
            min-width: 120px;
            text-align: right;
        }

        .danger-zone {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #444;
            text-align: center;
        }
        #reset-data-btn {
            background-color: #300;
            border-color: #f00;
            color: #fdd;
        }
        #reset-data-btn:hover {
            background-color: #500;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 99;
        }

        /* --- é€šçŸ¥ãƒãƒƒã‚¸ç”¨ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #shop-btn {
            position: relative; 
            overflow: visible;
        }

        #shop-btn.has-notification::after {
            content: "!";
            position: absolute;
            top: -10px;   
            right: -10px; 
            width: 24px;
            height: 24px;
            background-color: #ff0000; 
            color: #ffff00;            
            border-radius: 50%;        
            text-align: center;
            line-height: 24px;         
            font-weight: bold;
            font-size: 18px;
            border: 2px solid #fff;    
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            pointer-events: none;      
            z-index: 10;
        }

        /* --- ã‚¯ãƒªã‚¢ç”»é¢ç”¨ --- */
        #victory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
        }

        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .victory-content {
            position: relative;
            z-index: 2001;
            text-align: center;
        }

        .victory-content h1 {
            color: #ffff00;
            font-size: 80px;
            margin: 0;
            text-shadow: 0 0 20px #ffaa00;
            font-family: 'Arial', sans-serif;
            letter-spacing: 5px;
        }
        
        .victory-content p {
            color: #ff3333;
            font-size: 24px;
            margin-top: 20px;
            cursor: pointer;
            font-weight: bold;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .blink-text {
            animation: blink 1s infinite;
        }

        /* --- ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ¢ãƒ¼ãƒ€ãƒ« --- */
        .premium-item {
            border: 1px solid #ffd700;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #221a00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .premium-item button {
            background-color: #b8860b;
            color: #000;
            border-color: #ffd700;
        }
        .premium-item.purchased {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        /* --- ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ (å³ä¸‹) --- */
        #color-palette-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: none; /* è§£æ”¾ã•ã‚Œã‚‹ã¾ã§éè¡¨ç¤º */
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #fff;
        }
        #dirt-color-picker {
            width: 50px;
            height: 50px;
            cursor: pointer;
            border: 2px solid #fff;
            background: none;
            padding: 0;
        }
        #palette-label {
            font-size: 12px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- è±ªè¯ãªã‚¯ãƒªã‚¢ç”»é¢ç”¨CSS (Stage 100) --- */
        .true-ending-title {
            background: linear-gradient(135deg, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #d4af37;
            font-family: 'Times New Roman', serif; /* æ˜æœä½“ç³»ã§é«˜ç´šæ„Ÿã‚’å‡ºã™ */
            text-shadow: 0px 0px 50px rgba(255, 215, 0, 0.8);
            font-size: 110px !important;
            letter-spacing: 15px !important;
            transform: scale(1.1);
        }
        
        .true-ending-sub {
            color: #fff !important;
            font-family: serif;
            text-shadow: 0 0 20px #ffd700;
            font-size: 30px !important;
            letter-spacing: 5px;
            margin-top: 20px !important;
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div id="top-left-info" style="display: none;">
            <div id="cycle-container">
                <span id="cycle-count" class="cycle-text">001</span><span class="cycle-limit">/100</span>
            </div>
            <button id="premium-btn">ãƒ—ãƒ¬ãƒŸã‚¢ãƒ </button>
            <div id="ppt-container">P.Pt <span id="ppt-val">0</span></div>
        </div>

        <div id="center-panel">
            <button id="settings-btn">çµ±è¨ˆ</button>
            <div id="progress-container">
                é€²è¡Œç‡: <span id="progress">00.00</span>%
            </div>
        </div>

        <div id="right-panel">
            <button id="shop-btn">ã‚·ãƒ§ãƒƒãƒ—</button>
            <div id="money-container">
                æ‰€æŒé‡‘: <span id="money">0</span> G
            </div>
            <button id="sound-toggle-btn">SOUND: OFF</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1280" height="720"></canvas>
        <div id="entity-layer">
            <div id="hint-box"></div> </div>
    </div>

    <div id="bottom-info">
        <div id="zoom-control-area">
            <span id="zoom-indicator">ZOOM x<span id="zoom-val">1.0</span></span>
            <button id="reset-zoom-btn">Reset</button>
        </div>
        <div id="save-status">Auto Saving...</div>
    </div>

    <div id="overlay"></div>

    <div id="spam-modal" class="modal" style="display: none; height: auto; border-color: #ff0000;">
        <div class="modal-header" style="border-bottom-color: #ff0000;">
            <h2 style="color: #ff0000;">WARNING</h2>
        </div>
        <div class="modal-content" style="text-align: center; padding: 20px 0;">
            <p style="font-size: 1.2em; margin-bottom: 20px;">
                é€£æ‰“ãƒ„ãƒ¼ãƒ«ä½¿ã£ã¦ãªã„ï¼Ÿ<br>
                ãƒ•ã‚§ã‚¢ã«è¡Œã“ã†ã‚ˆ
            </p>
        </div>
        <div class="modal-footer" style="justify-content: center; border-top-color: #555;">
            <button id="spam-ok-btn" style="width: 100px; border-color: #ff0000; color: #ffcccc;">OK</button>
        </div>
    </div>

    <div id="shop-modal" class="modal" style="display: none;">
        <div class="modal-header">
            <h2>ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰</h2>
            <div class="page-indicator"><span id="page-num">1</span>/<span id="page-max">4</span></div>
        </div>
        
        <div id="upgrade-list" class="modal-content">
            </div>
        
        <div class="modal-footer">
            <div class="pagination-controls" id="shop-pagination">
                <button id="prev-page-btn">â†</button>
                <button id="next-page-btn">â†’</button>
            </div>
            <button class="close-modal">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <div id="premium-modal" class="modal" style="display: none; border-color: #ffd700;">
        <div class="modal-header" style="border-bottom-color: #ffd700;">
            <h2 style="color: #ffd700;">ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰</h2>
            <div style="color: #ffd700;">æ‰€æŒ P.Pt: <span id="modal-ppt-val">0</span></div>
            <div class="page-indicator" style="font-size: 0.8em; color: #ffd700;">
                <span id="premium-page-num">1</span>/<span id="premium-page-max">1</span>
            </div>
        </div>
        <div id="premium-list" class="modal-content">
            </div>
        <div class="modal-footer" style="border-top-color: #555; justify-content: space-between;">
            <div class="pagination-controls" id="premium-pagination" style="display:none;">
                <button id="prev-premium-page-btn">â†</button>
                <button id="next-premium-page-btn">â†’</button>
            </div>
            <button class="close-modal">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <div id="settings-modal" class="modal" style="display: none; height: auto;">
        <div class="modal-header">
            <h2>çµ±è¨ˆ</h2>
        </div>
        <div class="modal-content">
            <div style="margin-bottom: 20px; line-height: 1.8;">
                <div>ã‚¯ãƒªãƒƒã‚¯ã—ãŸå›æ•°: <span id="stat-clicks" style="font-weight:bold;">0</span> å›</div>
                <div>ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã—ãŸãƒ”ã‚¯ã‚»ãƒ«: <span id="stat-click-cleaned" style="font-weight:bold;">0</span> å€‹</div>
                <div>ãƒ­ãƒœãƒƒãƒˆæƒé™¤æ©ŸãŒæƒé™¤ã—ãŸãƒ”ã‚¯ã‚»ãƒ«: <span id="stat-robot-cleaned" style="font-weight:bold;">0</span> å€‹</div>
                <div>é€£æ‰“ãƒ„ãƒ¼ãƒ«è­¦å‘Šå›æ•°: <span id="stat-spam-warnings" style="font-weight:bold;">0</span> å›</div>
            </div>

            <hr style="border: 0; border-top: 1px solid #444; margin: 15px 0;">

            <p style="font-size: 0.9em; color: #aaa;">ã‚²ãƒ¼ãƒ ã®é€²è¡ŒçŠ¶æ³ã¯è‡ªå‹•ã§ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
            
            <div class="danger-zone">
                <p>â€»é€²è¡ŒçŠ¶æ³ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™</p>
                <button id="reset-data-btn">ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: flex-end;">
            <button class="close-modal">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <div id="victory-modal" style="display: none;">
        <canvas id="confetti-canvas"></canvas>
        <div class="victory-content">
            <h1 class="blink-text">CONGRATULATIONS</h1>
            <p>CLICK TO CLOSE</p>
            <p id="auto-progress-msg" style="font-size:16px; color:#aaa; display:none;">Auto Progress in 1s...</p>
        </div>
    </div>

    <div id="color-palette-container">
        <label id="palette-label" for="dirt-color-picker">DIRT COLOR</label>
        <input type="color" id="dirt-color-picker" value="#87CEEB">
    </div>

    <script>

        // --- Sound Manager (Web Audio API) ---
        class SoundManager {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.isEnabled = false;
            this.cleanBuffer = null;
        }

        init() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = 0.1; // å…¨ä½“ã®éŸ³é‡
            
            // ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆï¼ˆæƒé™¤éŸ³ç”¨ï¼‰
            const bufferSize = this.ctx.sampleRate * 2.0; // 2ç§’åˆ†
            this.cleanBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = this.cleanBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        }

        toggle() {
            this.isEnabled = !this.isEnabled;
            if (this.isEnabled && !this.ctx) this.init();
            if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            return this.isEnabled;
        }

        playTone(freq, type, duration, vol = 1.0) {
            if (!this.isEnabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }

        // æƒé™¤éŸ³ï¼ˆã‚¶ã‚¶ãƒƒï¼‰
        playClean() {
            if (!this.isEnabled || !this.ctx) return;
            // é€£ç¶šå†ç”Ÿã•ã‚Œã™ããªã„ã‚ˆã†ã«å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ”ãƒƒãƒã‚’å¤‰ãˆã‚‹
            const src = this.ctx.createBufferSource();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();

            src.buffer = this.cleanBuffer;
            src.loop = true;
            // å†ç”Ÿé€Ÿåº¦ã‚’å¤‰ãˆã¦éŸ³ç¨‹ã‚’å¤‰åŒ–ã•ã›ã‚‹
            src.playbackRate.value = 0.8 + Math.random() * 0.4;

            filter.type = 'lowpass';
            filter.frequency.value = 800;

            gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);

            src.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            
            src.start();
            src.stop(this.ctx.currentTime + 0.1);
        }

        // è³¼å…¥éŸ³ï¼ˆãƒãƒ£ãƒªãƒ¼ãƒ³ï¼‰
        playBuy() {
            if (!this.isEnabled) return;
            this.playTone(1200, 'sine', 0.1, 0.5);
            setTimeout(() => this.playTone(1800, 'sine', 0.4, 0.5), 50);
        }

        // ã‚¨ãƒ©ãƒ¼/è­¦å‘ŠéŸ³ï¼ˆãƒ–ãƒ–ãƒ¼ï¼‰
        playError() {
            if (!this.isEnabled) return;
            this.playTone(150, 'sawtooth', 0.3, 0.5);
        }

        // ãƒ—ãƒ©ã‚ºãƒç™ºå°„éŸ³ï¼ˆãƒ“ãƒ¥ãƒ³ï¼ï¼‰
        playPlasma() {
            if (!this.isEnabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);
            
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.3);
        }

        // ã‚¯ãƒªã‚¢ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬
        playVictory() {
            if (!this.isEnabled || !this.ctx) return;
            const now = this.ctx.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; // C E G C G C
            const times = [0, 0.1, 0.2, 0.3, 0.4, 0.6];
            const lens  = [0.1, 0.1, 0.1, 0.1, 0.2, 0.8];

            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + times[i]);
                gain.gain.setValueAtTime(0.3, now + times[i]);
                gain.gain.exponentialRampToValueAtTime(0.01, now + times[i] + lens[i]);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now + times[i]);
                osc.stop(now + times[i] + lens[i]);
            });
        }
    }
    
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
    const sound = new SoundManager();

        // --- è¨­å®šãƒ»å®šæ•° ---
        const WIDTH = 1280;
        const HEIGHT = 720;
        const TOTAL_PIXELS = WIDTH * HEIGHT;
        const SAVE_KEY = 'pixel_cleaner_save_v1';
        
        const ALL_UPGRADES = [
            // Page 1: Basic
            { id: 1, page: 1, type: 'brush', level: 1, cost: 50,   name: "ç¯„å›²å¼·åŒ– Lv.1", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒåºƒããªã‚‹" },
            { id: 2, page: 1, type: 'brush', level: 2, cost: 250,  name: "ç¯„å›²å¼·åŒ– Lv.2", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã•ã‚‰ã«åºƒããªã‚‹" },
            { id: 3, page: 1, type: 'brush', level: 3, cost: 1000,  name: "ç¯„å›²å¼·åŒ– Lv.3", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã‚‚ã£ã¨åºƒããªã‚‹" },
            { id: 4, page: 1, type: 'zoom',  level: 1, cost: 2000, name: "ã‚ºãƒ¼ãƒ æ©Ÿèƒ½",   desc: "ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 5, page: 1, type: 'robot', repeatable: false, cost: 2500, name: "ãƒ­ãƒœãƒƒãƒˆæƒé™¤æ©Ÿ", desc: "è‡ªå‹•ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆãŒæ‰‹ã«å…¥ã‚‹" },
            { id: 21, page: 1, type: 'hint', cost: 50000, name: "æ±šæŸ“ã‚»ãƒ³ã‚µãƒ¼", desc: "æƒé™¤ã§ãã¦ãªã„å ´æ‰€ã‚’ã‚ã‹ã‚Šã‚„ã™ã„ã‚ˆã†ã«å¼·èª¿ã™ã‚‹", reqProgress: 90 },
            
            // Page 2: Auto Clicker
            { id: 6,  page: 2, type: 'auto_click', rate: 8,  cost: 10000,  name: "å°å‹ãƒãƒ³ãƒ‡ã‚£ã‚¯ãƒªãƒ¼ãƒŠãƒ¼", desc: "é•·æŠ¼ã—ã§æƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 7,  page: 2, type: 'auto_click', rate: 12, cost: 20000,  name: "ãƒãƒ³ãƒ‡ã‚£ã‚¯ãƒªãƒ¼ãƒŠãƒ¼",   desc: "é•·æŠ¼ã—ã§ã‚¹ãƒ ãƒ¼ã‚ºã«æƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 8,  page: 2, type: 'auto_click', rate: 16, cost: 40000,  name: "ã‚µã‚¤ã‚¯ãƒ­ãƒ³ã‚¢ã‚¿ãƒƒãƒãƒ¡ãƒ³ãƒˆ", desc: "é•·æŠ¼ã—ã§ã‚‚ã£ã¨ã‚¹ãƒ ãƒ¼ã‚ºã«æƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 9,  page: 2, type: 'auto_click', rate: 24, cost: 60000,  name: "ã‚¿ãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ãƒ¼ãƒ˜ãƒƒãƒ‰",   desc: "é•·æŠ¼ã—ã§ã‹ãªã‚Šã‚¹ãƒ ãƒ¼ã‚ºã«æƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 10, page: 2, type: 'auto_click', rate: 32, cost: 90000, name: "å¸å¼•åŠ›ã®å¤‰ã‚ã‚‰ãªã„ãŸã ä¸€ã¤ã®", desc: "é•·æŠ¼ã—ã§ã¨ã¦ã‚‚ã‚¹ãƒ ãƒ¼ã‚ºã«æƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹" },
            { id: 22, page: 2, type: 'drag_clean', cost: 300000, name: "ãƒã‚¸ãƒƒã‚¯ãƒ–ãƒ©ã‚·", desc: "ç´ æ—©ããƒã‚¦ã‚¹ã‚’å‹•ã‹ã—ã¦ã‚‚ã€éš™é–“ãªãæƒé™¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹", reqPremium: true },

            // Page 3: Robot Upgrades
            { id: 11, page: 3, type: 'robot_area', level: 1, cost: 10000, name: "è‡ªå‹•æƒé™¤æ©Ÿç¯„å›²å¼·åŒ–1", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®æƒé™¤ç¯„å›²ãŒåºƒããªã‚‹" },
            { id: 12, page: 3, type: 'robot_speed', value: 0.2, cost: 20000, name: "è‡ªå‹•æƒé™¤æ©Ÿç§»å‹•é€Ÿåº¦å¼·åŒ–1", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®ç§»å‹•é€Ÿåº¦ãŒä¸ŠãŒã‚‹" },
            { id: 13, page: 3, type: 'robot_area', level: 2, cost: 40000, name: "è‡ªå‹•æƒé™¤æ©Ÿç¯„å›²å¼·åŒ–2", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®æƒé™¤ç¯„å›²ãŒã•ã‚‰ã«åºƒããªã‚‹" },
            { id: 14, page: 3, type: 'robot_speed', value: 0.3, cost: 60000, name: "è‡ªå‹•æƒé™¤æ©Ÿç§»å‹•é€Ÿåº¦å¼·åŒ–2", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®ç§»å‹•é€Ÿåº¦ãŒã•ã‚‰ã«ä¸ŠãŒã‚‹" },
            { id: 15, page: 3, type: 'robot_area', level: 3, cost: 90000, name: "è‡ªå‹•æƒé™¤æ©Ÿç¯„å›²å¼·åŒ–3", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®æƒé™¤ç¯„å›²ãŒã‚‚ã£ã¨åºƒãŒã‚‹" },
            { id: 23, page: 3, type: 'robot_area', level: 4, cost: 300000, name: "è‡ªå‹•æƒé™¤æ©Ÿç¯„å›²å¼·åŒ–æ¥µ", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆã®æƒé™¤ç¯„å›²ãŒã‹ãªã‚Šåºƒããªã‚‹", reqPremium: true },
            
            // Page 4: Brush Extension
            { id: 16, page: 4, type: 'brush', level: 4, cost: 10000,  name: "ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºæ‹¡å¼µ Lv.1", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒåºƒããªã‚‹" },
            { id: 17, page: 4, type: 'brush', level: 5, cost: 20000,  name: "ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºæ‹¡å¼µ Lv.2", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã•ã‚‰ã«åºƒããªã‚‹" },
            { id: 18, page: 4, type: 'brush', level: 6, cost: 40000,  name: "ãƒ–ãƒ©ã‚·ã‚µã‚¤ã‚ºæ‹¡å¼µ Lv.3", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã‚‚ã£ã¨åºƒããªã‚‹" },
            { id: 19, page: 4, type: 'brush', level: 7, cost: 60000,  name: "ãƒ¯ã‚¤ãƒ‰ãƒã‚ºãƒ«",        desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã‹ãªã‚Šåºƒããªã‚‹" },
            { id: 20, page: 4, type: 'brush', level: 8, cost: 90000, name: "ã‚¿ãƒ¼ãƒœãƒ¯ã‚¤ãƒ‰ãƒã‚ºãƒ«",  desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒã™ã”ãåºƒããªã‚‹" },
            { id: 24, page: 4, type: 'brush', level: 9, cost: 300000, name: "ã‚®ã‚¬ãƒ¯ã‚¤ãƒ‰ãƒã‚ºãƒ«", desc: "ã‚¯ãƒªãƒƒã‚¯ã§æƒé™¤ã§ãã‚‹ç¯„å›²ãŒåœ§å€’çš„ã«åºƒããªã‚‹", reqPremium: true }
        ];

        const INFINITE_BASE_COST = 700000;
        const INFINITE_COST_MULT = 1.3;
        const INFINITE_MAX_LEVEL = 10;

        

        const PREMIUM_UPGRADES = [
            // Page 1
            { id: 'p1', page: 1, costPt: 1, name: "ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚³ãƒ¼ã‚¹", desc: "ã‚·ãƒ§ãƒƒãƒ—ã«å¼·åŠ›ãªã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã™", unique: true },
            { id: 'p2', page: 1, baseCost: 1, name: "ãƒ­ãƒœãƒƒãƒˆè¿½åŠ ", desc: "ãƒ­ãƒœãƒƒãƒˆã‚’1å°è¿½åŠ ã—ã¾ã™ (æœ€å¤§3å›)", unique: false },
            { id: 'p3', page: 1, costPt: 3, name: "é™ç•Œçªç ´", desc: "ã‚·ãƒ§ãƒƒãƒ—ã®ãƒšãƒ¼ã‚¸5ã‚’è§£æ”¾ã—ã¾ã™", unique: true },
            { id: 'p4', page: 1, costPt: 5, name: "ãŠæƒé™¤AI", desc: "ãŠæƒé™¤ãƒ­ãƒœãƒƒãƒˆãŒåå°„ã™ã‚‹ã¨ãã«ã‚ã‚‹ç¨‹åº¦æ±šã‚Œã‚’ç‹™ã†ã‚ˆã†ã«ãªã‚Šã¾ã™", unique: true, reqRobotMax: true },
            { id: 'p5', page: 1, costPt: 5, name: "ã‚¯ãƒªãƒƒã‚¯ä»£è¡Œ", desc: "ç”»é¢å†…ã«ãƒã‚¦ã‚¹ãŒã‚ã‚‹ã ã‘ã§ã€å¸¸ã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã„ã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã™", unique: true, reqAI: true },
            
            // Page 2
            { id: 'p6', page: 2, name: "ãƒ­ãƒœãƒƒãƒˆé‡ç”£", desc: "ãƒ­ãƒœãƒƒãƒˆã‚’2å°è¿½åŠ ã—ã¾ã™ (æœ€å¤§3å›)", unique: false },
            { id: 'p7', page: 2, costPt: 10, name: "ãƒ—ãƒ©ã‚ºãƒ", desc: "3ç§’æ¯ã«ãƒ­ãƒœãƒƒãƒˆåŒå£«ãŒé€£æºã—ã€é–“ã®æ±šã‚Œã‚’ç„¼ãæ‰•ã„ã¾ã™", unique: true, reqMassProductionMax: true },
            { id: 'p8', page: 2, costPt: 5, name: "è‡ªå‹•é€²è¡Œ", desc: "ã‚¯ãƒªã‚¢ç”»é¢ã§1ç§’çµŒéã™ã‚‹ã¨ã€è‡ªå‹•ã§æ¬¡ã®å‘¨å›ã¸é€²ã¿ã¾ã™", unique: true, reqMassProductionMax: true },
            { id: 'p9', page: 2, costPt: 5, name: "æµ„åŒ–", desc: "é€²è¡Œç‡ãŒ98%ã‚’è¶…ãˆã‚‹ã¨ã€æ®‹ã‚Šã®æ±šã‚Œã‚’å…¨ã¦æ¶ˆæ»…ã•ã›ã¾ã™", unique: true, reqMassProductionMax: true },
            { id: 'p10', page: 2, costPt: 5, name: "ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ", desc: "ç”»é¢å³ä¸‹ã«æ±šã‚Œã®è‰²ã‚’è‡ªç”±ã«å¤‰æ›´ã§ãã‚‹ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ã—ã¾ã™", unique: true, reqMassProductionMax: true },

            // â˜…è¿½åŠ  Page 3
            { id: 'p11', page: 3, costPt: 10, name: "ãƒ—ãƒ©ã‚ºãƒå¼·åŒ–", desc: "ãƒ—ãƒ©ã‚ºãƒãŒæœ€ã‚‚è¿‘ã„ãƒ­ãƒœãƒƒãƒˆã¨æœ€ã‚‚é ã„ãƒ­ãƒœãƒƒãƒˆã®é–“ã§ç™ºç”Ÿã—ã¾ã™", unique: true },
            { id: 'p12', page: 3, costPt: 10, name: "ãƒ­ãƒœãƒƒãƒˆå¤§é‡ç”Ÿç”£", desc: "ãƒ­ãƒœãƒƒãƒˆã‚’5ä½“è¿½åŠ ã—ã¾ã™", unique: true },
            { id: 'p13', page: 3, costPt: 10, name: "ã‚²ãƒ¼ãƒŸãƒ³ã‚°ãƒ­ãƒœãƒƒãƒˆ", desc: "ãƒ­ãƒœãƒƒãƒˆãŒè™¹è‰²ã«è¼ãã‚ˆã†ã«ãªã‚Šã¾ã™", unique: true },
            { id: 'p14', page: 3, name: "ç„¡é™ãƒ­ãƒœãƒƒãƒˆå¢—è¨­", desc: "ãƒ­ãƒœãƒƒãƒˆã‚’1æ©Ÿè¿½åŠ ã—ã¾ã™ (ä½•åº¦ã§ã‚‚è³¼å…¥å¯)", unique: false, reqStage100: true }
        ];

        // --- DOMå–å¾— ---
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const entityLayer = document.getElementById('entity-layer');
        const progressEl = document.getElementById('progress');
        const moneyEl = document.getElementById('money');
        const hintBoxEl = document.getElementById('hint-box');
        
        const shopBtn = document.getElementById('shop-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const shopModal = document.getElementById('shop-modal');
        const settingsModal = document.getElementById('settings-modal');
        const overlay = document.getElementById('overlay');
        const closeModalBtns = document.querySelectorAll('.close-modal');
        const upgradeListEl = document.getElementById('upgrade-list');
        const resetDataBtn = document.getElementById('reset-data-btn');

        const zoomIndicator = document.getElementById('zoom-indicator');
        const zoomValEl = document.getElementById('zoom-val');
        const resetZoomBtn = document.getElementById('reset-zoom-btn');
        const saveStatusEl = document.getElementById('save-status');
        
        const pageNumEl = document.getElementById('page-num');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const shopPagination = document.getElementById('shop-pagination');

        const premiumPageNumEl = document.getElementById('premium-page-num');
        const premiumPageMaxEl = document.getElementById('premium-page-max');
        const prevPremiumPageBtn = document.getElementById('prev-premium-page-btn');
        const nextPremiumPageBtn = document.getElementById('next-premium-page-btn');
        const premiumPagination = document.getElementById('premium-pagination');

        // New Info DOM
        const topLeftInfo = document.getElementById('top-left-info');
        const cycleCountEl = document.getElementById('cycle-count');
        const premiumBtn = document.getElementById('premium-btn');
        const pptValEl = document.getElementById('ppt-val');
        
        const premiumModal = document.getElementById('premium-modal');
        const premiumListEl = document.getElementById('premium-list');
        const modalPptValEl = document.getElementById('modal-ppt-val');

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ---
        let cleanedCount = 0;
        let money = 0;
        let hasWon = false;
        
        let statTotalClicks = 0;
        let statClickCleaned = 0;
        let statRobotCleaned = 0;
        let statSpamWarnings = 0;
      
        let brushLevel = 0; 
        let isZoomUnlocked = false;
        
        let robots = []; 
        let robotSpeed = 0.1;
        let robotBrushLevel = 0; 

        let autoClickRate = 0; 
        let isMouseDown = false;
        let autoClickIntervalId = null;
        let currentMouseX = 0; 
        let currentMouseY = 0;

        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        let extraRobotCount = 0;      // ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã§è¿½åŠ ã—ãŸãƒ­ãƒœãƒƒãƒˆã®æ•°
        let isInfiniteUnlocked = false; // ãƒšãƒ¼ã‚¸5è§£æ”¾ãƒ•ãƒ©ã‚°
        let isRobotAIUnlocked = false;
        let isAutoHoverClickUnlocked = false;

        let autoClickAccumulator = 0; // ã‚¯ãƒªãƒƒã‚¯åˆ†ã‚’è²¯ã‚ã‚‹å¤‰æ•°
        let lastFrameTime = 0;        // å‰å›ã®ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“
        
        // ç„¡é™ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®è³¼å…¥æ•°ç®¡ç†
        let infiniteBrushCount = 0;
        let infiniteRobotAreaCount = 0;
        let infiniteRobotSpeedCount = 0;

        let lastCleanX = 0;
        let lastCleanY = 0;

        let cleanedPixels = new Set(); 
        let isResetting = false;
        
        let currentShopPage = 1;
        let lastUIUpdate = 0;

        const SPAM_CPS_THRESHOLD = 25; 
        const SPAM_DURATION_SEC = 3;   
        
        let currentSecondClicks = 0;
        let spamConsecutiveSeconds = 0;
        
        const spamModal = document.getElementById('spam-modal');
        const spamOkBtn = document.getElementById('spam-ok-btn');

        let isHintUnlocked = false; 
        let lastCleanTime = Date.now(); 
        let hintTargetIndex = -1; 

        // å‘¨å›ãƒ»ãƒ—ãƒ¬ãƒŸã‚¢ãƒ é–¢é€£
        let cycleCount = 0;      
        let premiumPoints = 0;   
        let isPremiumUnlocked = false; 
        let isDragCleanUnlocked = false;

        // ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚·ãƒ§ãƒƒãƒ—ç”¨å¤‰æ•°
        let currentPremiumPage = 1;
        let massProductionCount = 0; // ãƒ­ãƒœãƒƒãƒˆé‡ç”£ã®è³¼å…¥å›æ•°
        let isPlasmaUnlocked = false; // ãƒ—ãƒ©ã‚ºãƒè§£æ”¾ãƒ•ãƒ©ã‚°
        let lastPlasmaTime = 0;
        
        // è‡ªå‹•é€²è¡Œãƒ»æµ„åŒ–ãƒ•ãƒ©ã‚°
        let isAutoProgressUnlocked = false;
        let isPurificationUnlocked = false;

        // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆé–¢é€£å¤‰æ•°
        let dirtColor = '#87CEEB'; 
        let isColorPaletteUnlocked = false;
        const dirtColorPicker = document.getElementById('dirt-color-picker');
        const colorPaletteContainer = document.getElementById('color-palette-container');

        // â˜…è¿½åŠ : ãƒšãƒ¼ã‚¸3ã®ã‚¢ã‚¤ãƒ†ãƒ ãƒ•ãƒ©ã‚°
        let isPlasmaBoostUnlocked = false;
        let isGamingRobotUnlocked = false;
        let isRobotMassProduction5Unlocked = false; // ãƒ­ãƒœãƒƒãƒˆå¤§é‡ç”Ÿç”£(5ä½“)

        // 1ç§’ã”ã¨ã«ã‚¯ãƒªãƒƒã‚¯æ•°ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼
        setInterval(() => {
            if (spamModal.style.display === 'flex') {
                currentSecondClicks = 0;
                return;
            }

            if (currentSecondClicks >= SPAM_CPS_THRESHOLD) {
                spamConsecutiveSeconds++;
            } else {
                spamConsecutiveSeconds = 0;
            }

            if (spamConsecutiveSeconds >= SPAM_DURATION_SEC) {
                openModal(spamModal);
                sound.playError(); 
                statSpamWarnings++;
                overlay.removeEventListener('click', closeAllModals); 
            }

            currentSecondClicks = 0;
        }, 1000);

        // ãŠä»•ç½®ãè§£é™¤ãƒœã‚¿ãƒ³
        spamOkBtn.addEventListener('click', () => {
            closeAllModals();
            spamConsecutiveSeconds = 0;
            currentSecondClicks = 0;
            overlay.addEventListener('click', closeAllModals);
        });

        // --- åˆæœŸåŒ– ---
        canvas.style.backgroundColor = dirtColor; // èƒŒæ™¯è‰²ã‚’æ±šã‚Œã®è‰²ã«ã™ã‚‹
        ctx.clearRect(0, 0, WIDTH, HEIGHT);       // ã‚­ãƒ£ãƒ³ãƒã‚¹è‡ªä½“ã¯é€æ˜ã«ã™ã‚‹

        // ===============================================
        //  é–¢æ•°å®šç¾©
        // ===============================================

        function openModal(modal) {
            modal.style.display = 'flex'; 
            overlay.style.display = 'block';
        }

        function closeAllModals() {
            shopModal.style.display = 'none';
            settingsModal.style.display = 'none';
            spamModal.style.display = 'none';
            premiumModal.style.display = 'none';
            overlay.style.display = 'none';
        }

        function checkPurchased(item) {
            if (!item) return false;
            if (item.type === 'brush') return (brushLevel >= item.level);
            if (item.type === 'zoom') return isZoomUnlocked;
            if (item.type === 'hint') return isHintUnlocked; 
            if (item.type === 'robot') return (robots.length > 0);
            if (item.type === 'auto_click') return (autoClickRate >= item.rate);
            if (item.type === 'robot_area') return (robotBrushLevel >= item.level);
            if (item.type === 'robot_speed') return (robotSpeed >= item.value - 0.001);
            if (item.type === 'drag_clean') return isDragCleanUnlocked;
            if (item.type === 'infinite_brush') return (infiniteBrushCount >= item.level);
            if (item.type === 'infinite_robot_area') return (infiniteRobotAreaCount >= item.level);
            if (item.type === 'infinite_robot_speed') return (infiniteRobotSpeedCount >= item.level);
            return false;
        }

        function hideRemainingItems(items, startIndex) {
            for (let j = startIndex; j < items.length; j++) {
                const domId = `shop-item-${items[j].id}`;
                const el = document.getElementById(domId);
                if (el) el.style.display = 'none';
            }
        }

        function updateShopList(forceRebuild = false) {
            // æœ€å¤§ãƒšãƒ¼ã‚¸æ•°ã®è¨ˆç®—
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);

            // ãƒšãƒ¼ã‚¸æ•°è¡¨ç¤ºã®æ›´æ–°
            pageNumEl.textContent = currentShopPage;
            const pageMaxEl = document.getElementById('page-max');
            if (pageMaxEl) pageMaxEl.textContent = maxPage;
            
            if (maxPage > 1) {
                shopPagination.style.display = 'flex';
                prevPageBtn.disabled = (currentShopPage <= 1);
                nextPageBtn.disabled = (currentShopPage >= maxPage);
            } else {
                shopPagination.style.display = 'none';
            }

            if (forceRebuild) upgradeListEl.innerHTML = '';

            // â˜…ä¿®æ­£: ãƒšãƒ¼ã‚¸5ï¼ˆç„¡é™å¼·åŒ–ï¼‰ã®å‡¦ç†
            // é‡è¤‡ã‚’é˜²ããŸã‚ã€IDã‚’ä½¿ã£ã¦ã€Œæ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ã€ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™
            if (currentShopPage === 5) {
                const infinites = [
                    { type: 'infinite_brush', id: 'inf-brush', name: "ã€é™ç•Œçªç ´ã€‘ãƒ–ãƒ©ã‚·æ‹¡å¼µ", baseDesc: "ãƒ–ãƒ©ã‚·åŠå¾„ ã‚¢ãƒƒãƒ—", count: infiniteBrushCount },
                    { type: 'infinite_robot_area', id: 'inf-area', name: "ã€é™ç•Œçªç ´ã€‘ãƒ­ãƒœãƒƒãƒˆç¯„å›²", baseDesc: "ãƒ­ãƒœãƒƒãƒˆæƒé™¤åŠå¾„ ã‚¢ãƒƒãƒ—", count: infiniteRobotAreaCount },
                    { type: 'infinite_robot_speed', id: 'inf-speed', name: "ã€é™ç•Œçªç ´ã€‘ãƒ­ãƒœãƒƒãƒˆé€Ÿåº¦", baseDesc: "ãƒ­ãƒœãƒƒãƒˆé€Ÿåº¦ ã‚¢ãƒƒãƒ—", count: infiniteRobotSpeedCount }
                ];

                infinites.forEach(inf => {
                    const nextLevel = inf.count + 1;
                    const cost = Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, inf.count));
                    
                    // IDã‚’ä½¿ã£ã¦æ—¢å­˜ã®è¦ç´ ã‚’æ¢ã™
                    const domId = `shop-item-${inf.id}`;
                    let div = document.getElementById(domId);

                    // å­˜åœ¨ã—ãªã„å ´åˆã®ã¿æ–°è¦ä½œæˆ
                    if (!div) {
                        div = document.createElement('div');
                        div.id = domId;
                        div.className = 'upgrade-item';
                        div.innerHTML = `
                            <div class="upgrade-info">
                                <div class="inf-name-display" style="font-weight:bold; font-size:1.1em;"></div>
                                <div style="font-size:0.8em; color:#aaa;">${inf.baseDesc}</div>
                            </div>
                            <div class="action-part">
                                <button class="infinite-buy-btn"></button>
                            </div>
                        `;
                        upgradeListEl.appendChild(div);
                    }

                    // --- æ¯å›æ›´æ–°ã™ã‚‹ç®‡æ‰€ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã€ã‚³ã‚¹ãƒˆã€ãƒœã‚¿ãƒ³çŠ¶æ…‹ï¼‰ ---
                    
                    // ãƒ¬ãƒ™ãƒ«è¡¨è¨˜ã®æ›´æ–°
                    div.querySelector('.inf-name-display').textContent = `${inf.name} Lv.${nextLevel}`;
                    
                    // ãƒœã‚¿ãƒ³ã®æ›´æ–°
                    const btn = div.querySelector('button');
                    btn.dataset.type = inf.type;
                    btn.dataset.cost = cost;
                    btn.textContent = `${cost.toLocaleString()} G`;
                    
                    // è³¼å…¥å¯å¦ãƒã‚§ãƒƒã‚¯
                    const canBuy = (money >= cost);
                    btn.disabled = !canBuy;
                });
                return; // ãƒšãƒ¼ã‚¸5ã®å‡¦ç†ã¯ã“ã“ã§çµ‚äº†
            }

            // --- ä»¥ä¸‹ã€é€šå¸¸ãƒšãƒ¼ã‚¸ï¼ˆ1ã€œ4ï¼‰ã®å‡¦ç† ---
            const itemsToShow = ALL_UPGRADES.filter(item => item.page === currentShopPage);

            for (let i = 0; i < itemsToShow.length; i++) {
                const item = itemsToShow[i];
                
                // è¡¨ç¤ºæ¡ä»¶ãƒã‚§ãƒƒã‚¯
                if (item.reqProgress && cycleCount === 0) {
                    const currentPercent = (cleanedCount / TOTAL_PIXELS) * 100;
                    if (currentPercent < item.reqProgress) {
                        const domId = `shop-item-${item.id}`;
                        const el = document.getElementById(domId);
                        if (el) el.style.display = 'none';
                        continue; 
                    }
                }
                if (item.reqInfinite && !isInfiniteUnlocked) continue;
                if (item.reqPremium && !isPremiumUnlocked) {
                     const domId = `shop-item-${item.id}`;
                     const el = document.getElementById(domId);
                     if (el) el.style.display = 'none';
                     continue;
                }

                let isPurchased = checkPurchased(item);

                // é€šå¸¸ãƒšãƒ¼ã‚¸ã®ãƒ­ã‚¸ãƒƒã‚¯
                if (i > 0) {
                    const prevItem = itemsToShow[i-1];
                    if (!checkPurchased(prevItem)) {
                         const domId = `shop-item-${item.id}`;
                         const el = document.getElementById(domId);
                         if (el) el.style.display = 'none';
                         continue;
                    }
                }

                // DOMä½œæˆãƒ»è¡¨ç¤ºæ›´æ–°
                const domId = `shop-item-${item.id}`;
                let div = document.getElementById(domId);

                if (!div) {
                    div = document.createElement('div');
                    div.id = domId;
                    div.className = 'upgrade-item';
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'upgrade-info';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.textContent = item.name;
                    const descDiv = document.createElement('div');
                    descDiv.textContent = item.desc;
                    
                    infoDiv.appendChild(nameDiv);
                    infoDiv.appendChild(descDiv);

                    const actionPart = document.createElement('div');
                    actionPart.className = 'action-part';

                    div.appendChild(infoDiv);
                    div.appendChild(actionPart);
                    upgradeListEl.appendChild(div);
                }

                if (isPurchased) {
                    if (!div.classList.contains('purchased')) {
                        div.classList.add('purchased');
                        div.classList.remove('next-up');
                        const actionPart = div.querySelector('.action-part');
                        actionPart.innerHTML = '<div class="status-text">æ¸ˆ</div>';
                    }
                } else {
                    if (!div.classList.contains('next-up')) {
                        div.classList.add('next-up');
                        div.classList.remove('purchased');
                        const actionPart = div.querySelector('.action-part');
                        actionPart.innerHTML = `<button data-id="${item.id}">${item.cost.toLocaleString()} G</button>`;
                    } else {
                        const btn = div.querySelector('button');
                        if (btn) {
                            const canBuy = (money >= item.cost);
                            if (btn.disabled === canBuy) { 
                                btn.disabled = !canBuy;
                            }
                        }
                    }
                }
                div.style.display = 'flex'; 
            }
        }

        function onCleanHit(idx) {
            lastCleanTime = Date.now(); 
            if (idx === hintTargetIndex) {
                hintTargetIndex = -1;
                hintBoxEl.style.display = 'none';
            }
        }

        function updateUI() {
            moneyEl.textContent = money.toLocaleString();
            let percentage = (cleanedCount / TOTAL_PIXELS) * 100;

            if (cleanedCount < TOTAL_PIXELS) {
                if (percentage > 99.99) {
                    percentage = 99.99;
                }
            }
            progressEl.textContent = percentage.toFixed(2);
            
            checkVictory(); 
            
            if (cycleCount > 0 || premiumPoints > 0) {
                topLeftInfo.style.display = 'flex';
                const dispNum = (cycleCount + 1).toString().padStart(3, '0');
                cycleCountEl.textContent = dispNum;
                pptValEl.textContent = premiumPoints;

                // ã‚¹ãƒ†ãƒ¼ã‚¸100ä»¥ä¸Šã§åˆ†æ¯ã‚’éš ã™å‡¦ç†
                const cycleLimitEl = document.querySelector('.cycle-limit');
                if (cycleLimitEl) {
                    if (cycleCount >= 100) {
                        cycleLimitEl.style.display = 'none';
                    } else {
                        cycleLimitEl.style.display = 'inline';
                    }
                }
            }

            if (isZoomUnlocked) {
                zoomIndicator.style.display = 'block';
                zoomValEl.textContent = zoomLevel.toFixed(1);
                resetZoomBtn.style.display = (zoomLevel !== 1.0) ? 'block' : 'none';
            } else {
                zoomIndicator.style.display = 'none';
                resetZoomBtn.style.display = 'none';
            }

            if (isColorPaletteUnlocked) {
                colorPaletteContainer.style.display = 'flex';
            } else {
                colorPaletteContainer.style.display = 'none';
            }

            if (shopModal.style.display === 'flex') {
                updateShopList();
            }

            updateNotification();
            updateGamingLook();

            // â˜…è¿½åŠ : é€£æ‰“è­¦å‘ŠãŒ1å›ä»¥ä¸Šã‚ã‚‹å ´åˆã€çµ±è¨ˆãƒœã‚¿ãƒ³ã‚’èµ¤ãã™ã‚‹
            if (statSpamWarnings > 0) {
                settingsBtn.style.color = '#ff0000';
                settingsBtn.style.borderColor = '#ff0000'; // è¦–èªæ€§ã®ãŸã‚æ ç·šã‚‚èµ¤ãã—ã¦ã„ã¾ã™
            } else {
                // é€šå¸¸æ™‚ï¼ˆãƒªã‚»ãƒƒãƒˆå«ã‚€ï¼‰ã¯ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å…ƒã«æˆ»ã™
                settingsBtn.style.color = '';
                settingsBtn.style.borderColor = '';
            }
        }

        // â˜…è¿½åŠ : ãƒ­ãƒœãƒƒãƒˆã«ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸ã™ã‚‹
        function updateGamingLook() {
            if (isGamingRobotUnlocked) {
                robots.forEach(r => {
                    if (!r.el.classList.contains('gaming')) {
                        r.el.classList.add('gaming');
                    }
                });
            }
        }

        function updateNotification() {
            let hasUpgradeable = false;
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);

            // ãƒšãƒ¼ã‚¸5ï¼ˆç„¡é™å¼·åŒ–ï¼‰ã®ãƒã‚§ãƒƒã‚¯
            if (isInfiniteUnlocked) {
                const costs = [
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteBrushCount)),
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteRobotAreaCount)),
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteRobotSpeedCount))
                ];
                // ã©ã‚Œã‹ä¸€ã¤ã§ã‚‚è²·ãˆã‚‹ãªã‚‰é€šçŸ¥
                if (costs.some(c => money >= c)) {
                    hasUpgradeable = true;
                }
            }

            // é€šå¸¸ãƒšãƒ¼ã‚¸ï¼ˆ1ã€œ4ï¼‰ã®ãƒã‚§ãƒƒã‚¯
            if (!hasUpgradeable) {
                for (let page = 1; page <= 4; page++) {
                    const items = ALL_UPGRADES.filter(u => u.page === page);
                    for (let item of items) {
                        if (checkPurchased(item)) continue;
                        
                        if (item.reqProgress && cycleCount === 0) {
                            const currentPercent = (cleanedCount / TOTAL_PIXELS) * 100;
                            if (currentPercent < item.reqProgress) continue;
                        }
                        if (item.reqPremium && !isPremiumUnlocked) continue;
                        if (item.reqInfinite) continue; // infiniteç³»ã¯ALL_UPGRADESã‹ã‚‰å‰Šé™¤ã—ãŸã®ã§ã“ã“ã¯åŸºæœ¬é€šã‚‰ãªã„

                        if (money >= item.cost) {
                            hasUpgradeable = true;
                            break;
                        }
                    }
                    if (hasUpgradeable) break;
                }
            }

            if (hasUpgradeable) {
                shopBtn.classList.add('has-notification');
            } else {
                shopBtn.classList.remove('has-notification');
            }
        }

        function saveGame() {
            if (isResetting) return;
            showSaveStatus();
            
            // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åœ§ç¸®ä¿å­˜
            const buffer = new Uint8Array(Math.ceil(TOTAL_PIXELS / 8));
            for (let idx of cleanedPixels) {
                const byteIndex = Math.floor(idx / 8);
                const bitIndex = idx % 8;
                buffer[byteIndex] |= (1 << bitIndex);
            }
            let binary = '';
            const len = buffer.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(buffer[i]);
            }
            const pixelData = btoa(binary);

            const robotsData = robots.map(r => ({
                x: r.x, y: r.y, dirX: r.dirX, dirY: r.dirY
            }));

            const saveData = {
                // â˜…è¿½åŠ : ã‚µã‚¦ãƒ³ãƒ‰çŠ¶æ…‹ã®ä¿å­˜
                isSoundEnabled: sound.isEnabled,

                money: money,
                brushLevel: brushLevel,
                isZoomUnlocked: isZoomUnlocked,
                isHintUnlocked: isHintUnlocked,
                robotSpeed: robotSpeed,
                robotBrushLevel: robotBrushLevel, 
                autoClickRate: autoClickRate, 
                currentShopPage: currentShopPage, 
                statTotalClicks: statTotalClicks,
                statClickCleaned: statClickCleaned,
                statRobotCleaned: statRobotCleaned,
                statSpamWarnings: statSpamWarnings,
                cycleCount: cycleCount,
                premiumPoints: premiumPoints,
                isPremiumUnlocked: isPremiumUnlocked,
                isDragCleanUnlocked: isDragCleanUnlocked,
                extraRobotCount: extraRobotCount,
                isInfiniteUnlocked: isInfiniteUnlocked,
                isRobotAIUnlocked: isRobotAIUnlocked,
                isAutoHoverClickUnlocked: isAutoHoverClickUnlocked,
                massProductionCount: massProductionCount,
                infiniteBrushCount: infiniteBrushCount,
                infiniteRobotAreaCount: infiniteRobotAreaCount,
                infiniteRobotSpeedCount: infiniteRobotSpeedCount,
                isPlasmaUnlocked: isPlasmaUnlocked,
                isAutoProgressUnlocked: isAutoProgressUnlocked,
                isPurificationUnlocked: isPurificationUnlocked,
                dirtColor: dirtColor,
                isColorPaletteUnlocked: isColorPaletteUnlocked,
                isPlasmaBoostUnlocked: isPlasmaBoostUnlocked,
                isGamingRobotUnlocked: isGamingRobotUnlocked,
                isRobotMassProduction5Unlocked: isRobotMassProduction5Unlocked,
                infiniteRobotAddCount: infiniteRobotAddCount,
                
                robots: robotsData,
                pixels: pixelData
            };

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.error("Save failed:", e);
            }
        }

        function loadGame() {
            const json = localStorage.getItem(SAVE_KEY);
            if (!json) return false;

            try {
                const data = JSON.parse(json);
                infiniteRobotAddCount = data.infiniteRobotAddCount || 0;

                // â˜…è¿½åŠ : ã‚µã‚¦ãƒ³ãƒ‰çŠ¶æ…‹ã®èª­ã¿è¾¼ã¿ã¨å¾©å…ƒ
                if (data.isSoundEnabled !== undefined) {
                    sound.isEnabled = data.isSoundEnabled;
                    
                    // ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ã‚’æ›´æ–°
                    const soundBtn = document.getElementById('sound-toggle-btn');
                    if (soundBtn) {
                        soundBtn.textContent = sound.isEnabled ? "SOUND: ON" : "SOUND: OFF";
                        soundBtn.style.color = sound.isEnabled ? "#0f0" : "#fff";
                        soundBtn.style.borderColor = sound.isEnabled ? "#0f0" : "#fff";
                    }

                    // ã‚µã‚¦ãƒ³ãƒ‰ONã®å ´åˆã€æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§AudioContextã‚’åˆæœŸåŒ–ã™ã‚‹
                    if (sound.isEnabled) {
                        const initAudioOnFirstClick = () => {
                            if (!sound.ctx) sound.init();
                            if (sound.ctx && sound.ctx.state === 'suspended') sound.ctx.resume();
                            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤ï¼ˆ1å›ã ã‘å®Ÿè¡Œï¼‰
                            window.removeEventListener('click', initAudioOnFirstClick);
                            window.removeEventListener('keydown', initAudioOnFirstClick);
                        };
                        window.addEventListener('click', initAudioOnFirstClick);
                        window.addEventListener('keydown', initAudioOnFirstClick);
                    }
                }

                money = data.money || 0;
                brushLevel = data.brushLevel || 0;
                isZoomUnlocked = data.isZoomUnlocked || false;
                isHintUnlocked = data.isHintUnlocked || false;
                autoClickRate = data.autoClickRate || 0;
                currentShopPage = data.currentShopPage || 1;
                robotSpeed = (data.robotSpeed !== undefined) ? data.robotSpeed : 0.1;
                robotBrushLevel = (data.robotBrushLevel !== undefined) ? data.robotBrushLevel : 0;
                statTotalClicks = data.statTotalClicks || 0;
                statClickCleaned = data.statClickCleaned || 0;
                statRobotCleaned = data.statRobotCleaned || 0;
                statSpamWarnings = data.statSpamWarnings || 0;
                
                cycleCount = data.cycleCount || 0;
                premiumPoints = data.premiumPoints || 0;
                isPremiumUnlocked = data.isPremiumUnlocked || false;
                isDragCleanUnlocked = data.isDragCleanUnlocked || false;

                extraRobotCount = data.extraRobotCount || 0;
                isInfiniteUnlocked = data.isInfiniteUnlocked || false;
                isRobotAIUnlocked = data.isRobotAIUnlocked || false;
                isAutoHoverClickUnlocked = data.isAutoHoverClickUnlocked || false;
                massProductionCount = data.massProductionCount || 0;
                infiniteBrushCount = data.infiniteBrushCount || 0;
                infiniteRobotAreaCount = data.infiniteRobotAreaCount || 0;
                infiniteRobotSpeedCount = data.infiniteRobotSpeedCount || 0;
                
                isPlasmaUnlocked = data.isPlasmaUnlocked || false;
                isAutoProgressUnlocked = data.isAutoProgressUnlocked || false;
                isPurificationUnlocked = data.isPurificationUnlocked || false;

                dirtColor = data.dirtColor || '#87CEEB';
                isColorPaletteUnlocked = data.isColorPaletteUnlocked || false;

                isPlasmaBoostUnlocked = data.isPlasmaBoostUnlocked || false;
                isGamingRobotUnlocked = data.isGamingRobotUnlocked || false;
                isRobotMassProduction5Unlocked = data.isRobotMassProduction5Unlocked || false;

                if (dirtColorPicker) dirtColorPicker.value = dirtColor;
                if (canvas) canvas.style.backgroundColor = dirtColor;

                // ãƒ­ãƒœãƒƒãƒˆã®å¾©å…ƒ
                robots.forEach(r => r.el.remove());
                robots = [];
                if (data.robots && Array.isArray(data.robots)) {
                    data.robots.forEach(r => {
                        let dX = r.dirX;
                        let dY = r.dirY;
                        if (dX === undefined && r.dx !== undefined) dX = Math.sign(r.dx);
                        if (dY === undefined && r.dy !== undefined) dY = Math.sign(r.dy);
                        if (!dX) dX = 1;
                        if (!dY) dY = 1;
                        createRobotEntity(r.x, r.y, dX, dY);
                    });
                }

                // æƒé™¤æ¸ˆã¿ãƒ”ã‚¯ã‚»ãƒ«ã®å¾©å…ƒ
                if (data.pixels) {
                    cleanedPixels.clear();
                    cleanedCount = 0;
                    const binary = atob(data.pixels);
                    const len = binary.length;

                    ctx.clearRect(0, 0, WIDTH, HEIGHT);
                    ctx.fillStyle = '#000000';

                    for (let i = 0; i < len; i++) {
                        const byte = binary.charCodeAt(i);
                        if (byte === 0) continue;
                        for (let bit = 0; bit < 8; bit++) {
                            if (byte & (1 << bit)) {
                                const idx = i * 8 + bit;
                                cleanedPixels.add(idx);
                                cleanedCount++;
                                const y = Math.floor(idx / WIDTH);
                                const x = idx % WIDTH;
                                ctx.fillRect(x, y, 1, 1);
                            }
                        }
                    }
                } else {
                    ctx.clearRect(0, 0, WIDTH, HEIGHT);
                }

                return true;
            } catch (e) {
                console.error("Load failed:", e);
                return false;
            }
        }

        function showSaveStatus() {
            saveStatusEl.style.opacity = 1;
            setTimeout(() => { saveStatusEl.style.opacity = 0; }, 2000);
        }

        function createRobotEntity(x, y, dirX, dirY) {
            const el = document.createElement('div');
            el.className = 'robot';
            if (isGamingRobotUnlocked) {
                el.classList.add('gaming');
            }
            entityLayer.appendChild(el);
            robots.push({ x: x, y: y, dirX: dirX, dirY: dirY, el: el });
        }

        function addRobot() {
            const x = Math.floor(Math.random() * WIDTH);
            const y = Math.floor(Math.random() * HEIGHT);
            const dirs = [{ dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 }];
            const dir = dirs[Math.floor(Math.random() * dirs.length)];
            createRobotEntity(x, y, dir.dx, dir.dy);
        }

        function buyItem(item) {
            if (money < item.cost) return;

            try {
                // é€šå¸¸ã‚¢ã‚¤ãƒ†ãƒ 
                if (item.type === 'brush') {
                    sound.playBuy();
                    money -= item.cost;
                    brushLevel = item.level;
                } else if (item.type === 'zoom') {
                    sound.playBuy();
                    money -= item.cost;
                    isZoomUnlocked = true;
                    alert("ã‚ºãƒ¼ãƒ æ©Ÿèƒ½ãŒè§£æ”¾ã•ã‚Œã¾ã—ãŸï¼");
                } else if (item.type === 'robot') {
                    sound.playBuy();
                    money -= item.cost;
                    addRobot();
                } else if (item.type === 'auto_click') {
                    sound.playBuy();
                    money -= item.cost;
                    autoClickRate = item.rate;
                } else if (item.type === 'robot_area') {
                    sound.playBuy();
                    money -= item.cost;
                    robotBrushLevel = item.level;
                } else if (item.type === 'robot_speed') {
                    sound.playBuy();
                    money -= item.cost;
                    robotSpeed = item.value;
                } else if (item.type === 'hint') {
                    sound.playBuy();
                    money -= item.cost;
                    isHintUnlocked = true;
                    alert("æ±šæŸ“ã‚»ãƒ³ã‚µãƒ¼ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸï¼\n3ç§’é–“æƒé™¤ãŒè¡Œã‚ã‚Œãªã„ã¨æœªæƒé™¤ç®‡æ‰€ã‚’å¼·èª¿è¡¨ç¤ºã—ã¾ã™ã€‚");
                } else if (item.type === 'drag_clean') {
                    sound.playBuy();
                    money -= item.cost;
                    isDragCleanUnlocked = true;
                    alert("ãƒã‚¸ãƒƒã‚¯ãƒ–ãƒ©ã‚·è§£æ”¾ï¼\nã‚¯ãƒªãƒƒã‚¯ã—ãŸã¾ã¾ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã™ã ã‘ã§æƒé™¤ãŒã§ãã¾ã™ï¼");
                }
                
                // ç„¡é™å¼·åŒ–ã‚¢ã‚¤ãƒ†ãƒ 
                if (item.type === 'infinite_brush') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteBrushCount = item.level;
                } else if (item.type === 'infinite_robot_area') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteRobotAreaCount = item.level;
                } else if (item.type === 'infinite_robot_speed') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteRobotSpeedCount = item.level;
                }

                updateUI();

            } catch (e) {
                console.error("Purchase error:", e);
            }
        }

        function buyInfiniteItem(type, cost) {
            if (money < cost) return;
            money -= cost;
            
            if (type === 'infinite_brush') infiniteBrushCount++;
            else if (type === 'infinite_robot_area') infiniteRobotAreaCount++;
            else if (type === 'infinite_robot_speed') infiniteRobotSpeedCount++;
            
            updateUI();
        }

        function cleanRobotArea(cx, cy) {
            let pixelsToClean = [];
            let radius = 2 + (robotBrushLevel || 0); 
            
            if (robotBrushLevel >= 4) {
                radius += 2;
            }

            radius += (infiniteRobotAreaCount * 4);

            const r2 = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy <= r2) {
                        pixelsToClean.push({x:dx, y:dy});
                    }
                }
            }

            let earned = 0;
            ctx.fillStyle = '#000000';
            pixelsToClean.forEach(p => {
                const tx = cx + p.x;
                const ty = cy + p.y;
                if (tx>=0 && tx<WIDTH && ty>=0 && ty<HEIGHT) {
                    const idx = ty*WIDTH + tx;
                    if (!cleanedPixels.has(idx)) {
                        ctx.fillRect(tx, ty, 1, 1);
                        cleanedPixels.add(idx);
                        onCleanHit(idx);
                        cleanedCount++;
                        earned++;
                    }
                }
            });
            return earned;
        }

        function updatePlasma() {
            if (!isPlasmaUnlocked || robots.length < 2) return;
            
            const now = Date.now();
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¿ã‚¤ãƒãƒ¼åˆ¤å®š (now - lastPlasmaTime < 3000) ã‚’å‰Šé™¤

            let rBase = 2 + (robotBrushLevel || 0);
            if (robotBrushLevel >= 4) rBase += 2;
            rBase += (infiniteRobotAreaCount * 4);
            const plasmaRadius = Math.max(1, Math.floor(rBase / 2));

            robots.forEach(r1 => {
                // â–  ãƒ­ãƒœãƒƒãƒˆå€‹åˆ¥ã®ã‚¿ã‚¤ãƒãƒ¼åˆæœŸåŒ–ï¼ˆåˆå›ã®ã¿ãƒ©ãƒ³ãƒ€ãƒ ã«ãšã‚‰ã™ï¼‰
                if (!r1.nextPlasmaTime) {
                    r1.nextPlasmaTime = now + Math.random() * 3000;
                }

                // ã¾ã æ’ƒã¦ãªã„ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
                if (now < r1.nextPlasmaTime) return;

                // --- ã“ã“ã‹ã‚‰æ¢ç´¢å‡¦ç† ---
                let nearest = null;
                let nearestDistSq = Infinity;
                let farthest = null;
                let farthestDistSq = -1;

                // é«˜é€ŸåŒ–ã®ãŸã‚ã€æ¢ç´¢ã‚‚ã€Œå…¨å“¡ã€ã§ã¯ãªãã€Œãƒ©ãƒ³ãƒ€ãƒ ãª10ä½“ã€ç¨‹åº¦ã«çµã‚‹æ‰‹ã‚‚ã‚ã‚Šã¾ã™ãŒã€
                // ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ†æ•£ã•ã›ãŸã®ã§å…¨æ¢ç´¢ã§ã‚‚ååˆ†è»½ã„ã¯ãšã§ã™ã€‚
                for (let i = 0; i < robots.length; i++) {
                    const r2 = robots[i];
                    if (r1 === r2) continue;

                    const dx = r2.x - r1.x;
                    const dy = r2.y - r1.y;
                    const distSq = dx*dx + dy*dy;
                    
                    // é ã™ãã‚‹ç›¸æ‰‹(ç”»é¢åŠåˆ†ä»¥ä¸Šé›¢ã‚Œã¦ã‚‹ãªã©)ã¯è¨ˆç®—å¯¾è±¡å¤–ã«ã™ã‚‹ç°¡æ˜“ãƒ•ã‚£ãƒ«ã‚¿ã‚’å…¥ã‚Œã¦ã‚‚è‰¯ã„
                    // if (distSq > (WIDTH/2)**2) continue; 

                    if (distSq < nearestDistSq) {
                        nearestDistSq = distSq;
                        nearest = r2;
                    }
                    if (isPlasmaBoostUnlocked) {
                        if (distSq > farthestDistSq) {
                            farthestDistSq = distSq;
                            farthest = r2;
                        }
                    }
                }

                let fired = false;
                if (nearest) {
                    firePlasma(r1, nearest, plasmaRadius);
                    fired = true;
                }
                if (isPlasmaBoostUnlocked && farthest && farthest !== nearest) {
                    firePlasma(r1, farthest, plasmaRadius);
                    fired = true;
                }

                // æ¬¡å›ã®ç™ºå°„æ™‚é–“ã‚’ã‚»ãƒƒãƒˆï¼ˆ3ç§’å¾Œ + ãƒ©ãƒ³ãƒ€ãƒ 0.5ç§’ï¼‰
                // firedãŒfalseï¼ˆç›¸æ‰‹ãŒã„ãªã‹ã£ãŸï¼‰å ´åˆã§ã‚‚ã€å°‘ã—å¾…æ©Ÿã•ã›ã‚‹
                r1.nextPlasmaTime = now + 3000 + Math.random() * 500;
            });
        }

        function firePlasma(r1, r2, radius) {
            // åº§æ¨™è¨ˆç®—
            const dx = r2.x - r1.x;
            const dy = r2.y - r1.y;
            const dist = Math.hypot(dx, dy);
            
            // â–  1. ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (DOMè¦ç´ ã«æˆ»ã™)
            // Canvasã«æãã¨æ¶ˆãˆãªããªã‚‹ãŸã‚ã€divè¦ç´ ã‚’ä½œã£ã¦æ¶ˆã™æ–¹å¼ã«æˆ»ã—ã¾ã™ã€‚
            const beam = document.createElement('div');
            beam.className = 'plasma-beam';
            
            // ã‚ºãƒ¼ãƒ ã‚„ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®(panX, panY)ã‚’è€ƒæ…®ã—ã¦åº§æ¨™å¤‰æ›
            const screenX1 = r1.x * zoomLevel + panX;
            const screenY1 = r1.y * zoomLevel + panY;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const screenDist = dist * zoomLevel;
            const screenThickness = (radius * 2) * zoomLevel;

            // ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
            beam.style.width = `${screenDist}px`;
            beam.style.height = `${Math.max(2, screenThickness)}px`;
            beam.style.left = `${screenX1}px`;
            beam.style.top = `${screenY1 - (Math.max(2, screenThickness)/2)}px`;
            beam.style.transform = `rotate(${angle}deg)`;
            
            // è¿½åŠ ã—ã¦ã€å°‘ã—çµŒã£ãŸã‚‰æ¶ˆã™ (ã“ã‚ŒãŒã€Œç·šãŒæ¶ˆãˆã‚‹ã€å‡¦ç†ã«ãªã‚Šã¾ã™)
            entityLayer.appendChild(beam);
            setTimeout(() => {
                beam.style.opacity = 0;
                setTimeout(() => beam.remove(), 500); 
            }, 100);

            // â–  2. ãƒ‡ãƒ¼ã‚¿ã®æƒé™¤å‡¦ç†ï¼ˆè¨ˆç®—ã®é–“å¼•ãã¯ç¶­æŒï¼‰
            // è² è·å¯¾ç­–ã®ãŸã‚ã€ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–“éš”ã‚’åºƒã’ã¦ã„ã¾ã™
            const stepSize = Math.max(4, radius); 
            const steps = Math.ceil(dist / stepSize);
            
            let earned = 0;
            const r2Sq = radius * radius;

            ctx.fillStyle = '#000000'; 

            for (let i = 0; i <= steps; i++) {
                const t = (steps === 0) ? 0 : i / steps;
                const cx = Math.floor(r1.x + dx * t);
                const cy = Math.floor(r1.y + dy * t);

                if (cx < -radius || cx >= WIDTH + radius || cy < -radius || cy >= HEIGHT + radius) continue;

                for (let py = -radius; py <= radius; py++) {
                    const ty = cy + py;
                    if (ty < 0 || ty >= HEIGHT) continue;

                    for (let px = -radius; px <= radius; px++) {
                        if (px*px + py*py <= r2Sq) {
                            const tx = cx + px;
                            if (tx < 0 || tx >= WIDTH) continue;

                            const idx = ty * WIDTH + tx;
                            
                            // ã¾ã æƒé™¤ã•ã‚Œã¦ã„ãªã„å ´æ‰€ã ã‘å¡—ã‚‹
                            if (!cleanedPixels.has(idx)) {
                                cleanedPixels.add(idx);
                                cleanedCount++;
                                earned++;
                                // ãƒ‡ãƒ¼ã‚¿ã‚’é»’ãå¡—ã‚‹ï¼ˆã“ã‚Œã¯æ¶ˆãˆãªãã¦OKï¼‰
                                ctx.fillRect(tx, ty, 1, 1);
                            }
                        }
                    }
                }
            }

            if (earned > 0) {
                money += earned;
                statRobotCleaned += earned;
                if (Math.random() < 0.3) sound.playClean(); 
            }

            if (Math.random() < 0.1) sound.playPlasma();
        }

        function updatePurification() {
            if (!isPurificationUnlocked || hasWon) return;
            if (cleanedCount >= TOTAL_PIXELS) return; 

            if (cleanedCount / TOTAL_PIXELS >= 0.98) {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                for (let i = 0; i < TOTAL_PIXELS; i++) {
                    if (!cleanedPixels.has(i)) {
                        cleanedPixels.add(i);
                    }
                }
                cleanedCount = TOTAL_PIXELS;
                updateUI(); 
            }
        }

        function updateHint() {
            if (!isHintUnlocked) return;
            if (cleanedCount >= TOTAL_PIXELS) {
                 hintBoxEl.style.display = 'none';
                 return;
            }

            if (Date.now() - lastCleanTime > 3000) {
                if (hintTargetIndex === -1) {
                    let startIndex = Math.floor(Math.random() * TOTAL_PIXELS);
                    for (let i = 0; i < TOTAL_PIXELS; i++) {
                        let idx = (startIndex + i) % TOTAL_PIXELS;
                        if (!cleanedPixels.has(idx)) {
                            hintTargetIndex = idx;
                            break;
                        }
                    }
                }

                if (hintTargetIndex !== -1) {
                    const tx = hintTargetIndex % WIDTH;
                    const ty = Math.floor(hintTargetIndex / WIDTH);

                    const size = Math.max(10, 10 * zoomLevel); 
                    const offset = size / 2 - (0.5 * zoomLevel); 
                    
                    const screenX = tx * zoomLevel + panX;
                    const screenY = ty * zoomLevel + panY;

                    hintBoxEl.style.width = `${size}px`;
                    hintBoxEl.style.height = `${size}px`;
                    
                    const centerX = screenX + (0.5 * zoomLevel);
                    const centerY = screenY + (0.5 * zoomLevel);

                    hintBoxEl.style.transform = `translate(${centerX - size/2}px, ${centerY - size/2}px)`;
                    hintBoxEl.style.display = 'block';
                }

            } else {
                hintTargetIndex = -1;
                hintBoxEl.style.display = 'none';
            }
        }

        function updateRobots() {
            let moneyEarnedThisFrame = 0;
            const TARGET_MAG = 1.414; 
            const currentRobotSpeed = robotSpeed + (infiniteRobotSpeedCount * 0.2);

            robots.forEach(robot => {
                robot.x += robot.dirX * currentRobotSpeed;
                robot.y += robot.dirY * currentRobotSpeed;

                let bounced = false;
                
                if (robot.x <= 0) {
                    robot.x = 0;
                    robot.dirX *= -1; 
                    robot.dirY += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                } else if (robot.x >= WIDTH) {
                    robot.x = WIDTH - 0.001;
                    robot.dirX *= -1;
                    robot.dirY += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                }

                if (robot.y <= 0) {
                    robot.y = 0;
                    robot.dirY *= -1; 
                    robot.dirX += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                } else if (robot.y >= HEIGHT) {
                    robot.y = HEIGHT - 0.001;
                    robot.dirY *= -1;
                    robot.dirX += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                }

                if (bounced && isRobotAIUnlocked) {
                    let hasDirtNearby = false;
                    const rCheck = 30;
                    const rCheckSq = rCheck * rCheck;
                    const cx = Math.floor(robot.x);
                    const cy = Math.floor(robot.y);
                    
                    for (let dy = -rCheck; dy <= rCheck; dy += 5) {
                        for (let dx = -rCheck; dx <= rCheck; dx += 5) {
                            if (dx*dx + dy*dy <= rCheckSq) {
                                const tx = cx + dx;
                                const ty = cy + dy;
                                if (tx >= 0 && tx < WIDTH && ty >= 0 && ty < HEIGHT) {
                                    if (!cleanedPixels.has(ty * WIDTH + tx)) {
                                        hasDirtNearby = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (hasDirtNearby) break;
                    }

                    if (!hasDirtNearby) {
                        let minDistSq = Infinity;
                        let targetX = -1;
                        let targetY = -1;

                        // ã€è»½é‡åŒ–ãƒ—ãƒ©ãƒ³Aã€‘ ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
                        // å…¨ç”»ç´ ã‚’è¦‹ã‚‹ã®ã§ã¯ãªãã€ãƒ©ãƒ³ãƒ€ãƒ ã«60ç®‡æ‰€ã»ã©ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦
                        // ãã®ä¸­ã§ä¸€ç•ªè¿‘ã„æ±šã‚Œã‚’ç›®æŒ‡ã—ã¾ã™ã€‚
                        // æ±šã‚ŒãŒãŸãã•ã‚“ã‚ã‚‹æ™‚ã¯ã€é«˜ç¢ºç‡ã§ã“ã‚Œã§ååˆ†ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã™ã€‚
                        const attempts = 60;
                        for (let i = 0; i < attempts; i++) {
                            const rx = Math.floor(Math.random() * WIDTH);
                            const ry = Math.floor(Math.random() * HEIGHT);
                            const idx = ry * WIDTH + rx;

                            if (!cleanedPixels.has(idx)) {
                                const dx = rx - robot.x;
                                const dy = ry - robot.y;
                                const distSq = dx*dx + dy*dy;
                                if (distSq < minDistSq) {
                                    minDistSq = distSq;
                                    targetX = rx;
                                    targetY = ry;
                                }
                            }
                        }

                        // ã€è»½é‡åŒ–ãƒ—ãƒ©ãƒ³Bã€‘ ç²—ã„èµ°æŸ»ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
                        // ãƒ©ãƒ³ãƒ€ãƒ ã§è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆï¼ˆï¼æ±šã‚ŒãŒæ®‹ã‚Šã‚ãšã‹ãªå ´åˆï¼‰ã®ã¿ã€
                        // ã‚°ãƒªãƒƒãƒ‰èµ°æŸ»ã‚’è¡Œã„ã¾ã™ãŒã€é–“éš”(step)ã‚’å¤§ããã—ã¦è² è·ã‚’ä¸‹ã’ã¾ã™ã€‚
                        if (targetX === -1) {
                            const remainingPixels = TOTAL_PIXELS - cleanedCount;
                            
                            // æ®‹ã‚Šãƒ”ã‚¯ã‚»ãƒ«æ•°ã«å¿œã˜ã¦ç²¾åº¦ã‚’å¤‰ãˆã‚‹ï¼ˆä»¥å‰ã‚ˆã‚Šç²—ãè¨­å®šï¼‰
                            // 20pxåˆ»ã¿ã§ã‚‚ååˆ†ãƒ­ãƒœãƒƒãƒˆã¯è¿‘ãã‚’é€šã‚Šã¾ã™
                            const step = (remainingPixels < 1000) ? 5 : 40; 
                            
                            // è² è·åˆ†æ•£ã®ãŸã‚ã€é–‹å§‹ä½ç½®ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ãšã‚‰ã™
                            const startY = Math.floor(Math.random() * step);
                            const startX = Math.floor(Math.random() * step);

                            for (let y = startY; y < HEIGHT; y += step) {
                                for (let x = startX; x < WIDTH; x += step) {
                                    const idx = y * WIDTH + x;
                                    if (!cleanedPixels.has(idx)) {
                                        const dx = x - robot.x;
                                        const dy = y - robot.y;
                                        const distSq = dx*dx + dy*dy;
                                        // ä»¥å‰è¦‹ã¤ã‘ãŸå€™è£œï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ¢ç´¢ã§ã®å€™è£œã¯ãªã„ã¯ãšã ãŒå¿µã®ãŸã‚ï¼‰ã‚ˆã‚Šè¿‘ã‘ã‚Œã°æ›´æ–°
                                        if (distSq < minDistSq) {
                                            minDistSq = distSq;
                                            targetX = x;
                                            targetY = y;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€æ–¹å‘ã‚’æ›´æ–°
                        if (targetX !== -1) {
                            const currentSpeed = Math.hypot(robot.dirX, robot.dirY);
                            if (currentSpeed > 0) {
                                const angle = Math.atan2(targetY - robot.y, targetX - robot.x);
                                robot.dirX = Math.cos(angle) * currentSpeed;
                                robot.dirY = Math.sin(angle) * currentSpeed;
                            }
                        }
                    }
                }

                if (bounced) { 
                    const currentMag = Math.hypot(robot.dirX, robot.dirY);
                    if (currentMag > 0) {
                        if (!isRobotAIUnlocked && currentMag < 0.1) {
                            robot.dirX = (Math.random() > 0.5 ? 1 : -1);
                            robot.dirY = (Math.random() > 0.5 ? 1 : -1);
                        } else {
                            const scale = TARGET_MAG / currentMag;
                            robot.dirX *= scale;
                            robot.dirY *= scale;
                        }
                    }
                }

                const px = Math.floor(robot.x);
                const py = Math.floor(robot.y);

                if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
                    moneyEarnedThisFrame += cleanRobotArea(px, py);
                }
            });
            
            if (moneyEarnedThisFrame > 0) {
                money += moneyEarnedThisFrame;
                statRobotCleaned += moneyEarnedThisFrame;
            }
        }

        function renderEntities() {
            const baseSize = 6; 
            const size = baseSize * zoomLevel;
            const offset = size / 2;

            robots.forEach(robot => {
                const screenX = robot.x * zoomLevel + panX;
                const screenY = robot.y * zoomLevel + panY;
                
                robot.el.style.transform = `translate(${screenX - offset}px, ${screenY - offset}px)`;
                robot.el.style.width = size + 'px';
                robot.el.style.height = size + 'px';
                robot.el.style.borderRadius = '50%';
            });
        }

        function clampPan() {
            const visualWidth = WIDTH * zoomLevel;
            const visualHeight = HEIGHT * zoomLevel;
            const containerW = 1280;
            const containerH = 720;
            if (zoomLevel <= 1.0) { panX = 0; panY = 0; }
            else {
                const minX = containerW - visualWidth;
                const minY = containerH - visualHeight;
                panX = Math.min(0, Math.max(minX, panX));
                panY = Math.min(0, Math.max(minY, panY));
            }
        }

        function applyTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
        }

        function cleanArea(cx, cy) {
            let pixelsToClean = [];
            
            if (brushLevel <= 3) {
                if (brushLevel === 0) pixelsToClean.push({x:0, y:0});
                else if (brushLevel === 1) pixelsToClean.push({x:0,y:0},{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0});
                else if (brushLevel >= 2) {
                    for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) pixelsToClean.push({x:dx,y:dy});
                    if (brushLevel === 3) pixelsToClean.push({x:0,y:-2},{x:0,y:2},{x:-2,y:0},{x:2,y:0});
                }
            } else {
                let radius = 2 + (brushLevel - 3); 
                if (brushLevel >= 9) {
                    radius += 5;
                }

                radius += (infiniteBrushCount * 4);

                const r2 = radius * radius;
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx*dx + dy*dy <= r2) {
                            pixelsToClean.push({x:dx, y:dy});
                        }
                    }
                }
            }

            let earned = 0;
            ctx.fillStyle = '#000000';
            pixelsToClean.forEach(p => {
                const tx = cx + p.x;
                const ty = cy + p.y;
                if (tx>=0 && tx<WIDTH && ty>=0 && ty<HEIGHT) {
                    const idx = ty*WIDTH + tx;
                    if (!cleanedPixels.has(idx)) {
                        ctx.fillRect(tx, ty, 1, 1);
                        cleanedPixels.add(idx);
                        onCleanHit(idx); 
                        cleanedCount++;
                        earned++;
                    }
                }
            });
            if (earned > 0) {
                money += earned;
                statClickCleaned += earned; 
            }
        }
        function attemptClean(clientX, clientY) {
            const rect = gameContainer.getBoundingClientRect();
            const relX = clientX - rect.left;
            const relY = clientY - rect.top;
            const canvasX = Math.floor((relX - panX) / zoomLevel);
            const canvasY = Math.floor((relY - panY) / zoomLevel);
            if (canvasX < 0 || canvasX >= WIDTH || canvasY < 0 || canvasY >= HEIGHT) return;
            cleanArea(canvasX, canvasY);
        }

        function startAutoClick() {
        }

        function stopAutoClick() {
        }

        // ===============================================
        //  ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ãƒ»å®Ÿè¡Œ 
        // ===============================================

        if (!loadGame()) {
            updateUI();
        } 
        if (robotSpeed === undefined) robotSpeed = 0.1;
        if (robotBrushLevel === undefined) robotBrushLevel = 0;

        requestAnimationFrame(gameLoop);
        setInterval(() => { saveGame(); }, 30000);
        window.addEventListener('beforeunload', () => { saveGame(); });

        shopBtn.addEventListener('click', () => {
            openModal(shopModal);
            updateShopList(true); 
        });
        settingsBtn.addEventListener('click', () => {
            const updateStat = (elementId, value) => {
                const el = document.getElementById(elementId);
                if (el) {
                    el.textContent = value.toLocaleString();
                    el.parentNode.style.display = (value > 0) ? 'block' : 'none';
                }
            };

            updateStat('stat-clicks', statTotalClicks);
            updateStat('stat-click-cleaned', statClickCleaned);
            updateStat('stat-robot-cleaned', statRobotCleaned);
            updateStat('stat-spam-warnings', statSpamWarnings);
            
            openModal(settingsModal);
        });

        // ãƒ—ãƒ¬ãƒŸã‚¢ãƒ é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
        premiumBtn.addEventListener('click', () => {
            updatePremiumShop();
            openModal(premiumModal);
        });

        function updatePremiumShop() {
            modalPptValEl.textContent = premiumPoints;
            premiumListEl.innerHTML = '';

            // â˜…å¤‰æ›´: ãƒšãƒ¼ã‚¸3ã®è§£æ”¾æ¡ä»¶åˆ¤å®š
            // ãƒšãƒ¼ã‚¸2ã®å®Œäº†æ¡ä»¶: ãƒ­ãƒœãƒƒãƒˆé‡ç”£(Lv3) + ãƒ—ãƒ©ã‚ºãƒ + è‡ªå‹•é€²è¡Œ + æµ„åŒ– + ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
            const isPage2Complete = (massProductionCount >= 3 && isPlasmaUnlocked && isAutoProgressUnlocked && isPurificationUnlocked && isColorPaletteUnlocked);
            

            
            // maxPageã®è¨ˆç®—
            let maxPage = 1;
            if (isAutoHoverClickUnlocked) maxPage = 2;
            if (isPage2Complete || cycleCount >= 100) maxPage = 3; 

            premiumPageNumEl.textContent = currentPremiumPage;
            premiumPageMaxEl.textContent = maxPage;

            if (maxPage > 1) {
                premiumPagination.style.display = 'flex';
                prevPremiumPageBtn.disabled = (currentPremiumPage <= 1);
                nextPremiumPageBtn.disabled = (currentPremiumPage >= maxPage);
            } else {
                premiumPagination.style.display = 'none';
            }

            const itemsToShow = PREMIUM_UPGRADES.filter(item => item.page === currentPremiumPage);

            itemsToShow.forEach(item => {
                // æ—¢å­˜ã®è§£æ”¾æ¡ä»¶
                if (item.reqRobotMax && extraRobotCount < 3) return;
                if (item.reqAI && !isRobotAIUnlocked) return;
                if (item.reqMassProductionMax && massProductionCount < 3) return; 
                if (item.reqStage100 && cycleCount < 100) return;

                const div = document.createElement('div');
                div.className = 'premium-item';
                
                let isPurchased = false;
                let cost = 0;
                let btnText = "";
                let disabled = false;

                // IDã”ã¨ã®å‡¦ç†...
                if (item.id === 'p1') {
                    isPurchased = isPremiumUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p2') { 
                    cost = Math.pow(2, extraRobotCount);
                    isPurchased = (extraRobotCount >= 3); 
                    btnText = isPurchased ? "å®Œå£²" : `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true; 
                } else if (item.id === 'p3') { 
                    isPurchased = isInfiniteUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true; 
                } else if (item.id === 'p4') {
                    isPurchased = isRobotAIUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true;
                } else if (item.id === 'p5') {
                    isPurchased = isAutoHoverClickUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true;
                } else if (item.id === 'p6') {
                    const costs = [4, 6, 8];
                    if (massProductionCount < 3) {
                        cost = costs[massProductionCount];
                        btnText = `${cost} Pt`;
                    } else {
                        isPurchased = true;
                        btnText = "å®Œå£²";
                    }
                } else if (item.id === 'p7') { 
                    isPurchased = isPlasmaUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p8') {
                    isPurchased = isAutoProgressUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p9') { 
                    isPurchased = isPurificationUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p10') { 
                    isPurchased = isColorPaletteUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                // â˜…è¿½åŠ : ãƒšãƒ¼ã‚¸3ã®ã‚¢ã‚¤ãƒ†ãƒ å‡¦ç†
                else if (item.id === 'p11') { // ãƒ—ãƒ©ã‚ºãƒå¼·åŒ–
                    isPurchased = isPlasmaBoostUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                else if (item.id === 'p12') { // ãƒ­ãƒœãƒƒãƒˆå¤§é‡ç”Ÿç”£
                    isPurchased = isRobotMassProduction5Unlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                else if (item.id === 'p13') { // ã‚²ãƒ¼ãƒŸãƒ³ã‚°ãƒ­ãƒœãƒƒãƒˆ
                    isPurchased = isGamingRobotUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                else if (item.id === 'p14') {
                    // ã‚³ã‚¹ãƒˆè¨ˆç®—: 8 * 1.5ã®nä¹— (åˆ‡ã‚Šä¸Šã’)
                    cost = Math.ceil(8 * Math.pow(1.5, infiniteRobotAddCount));
                    btnText = `${cost.toLocaleString()} Pt`;
                }

                let btnHtml = '';
                if (isPurchased) {
                    div.classList.add('purchased');
                    btnHtml = '<div>æ¸ˆ</div>';
                } else {
                    const canBuy = (premiumPoints >= cost) && !disabled;
                    const disabledAttr = canBuy ? '' : 'disabled';
                    btnHtml = `<button onclick="buyPremiumItem('${item.id}')" ${disabledAttr}>${btnText}</button>`;
                }

                div.innerHTML = `
                    <div class="upgrade-info">
                        <div>${item.name}</div>
                        <div style="font-size:0.8em; color:#ccc;">${item.desc}</div>
                    </div>
                    <div class="action-part">${btnHtml}</div>
                `;
                premiumListEl.appendChild(div);
            });
        }
        window.buyPremiumItem = function(id) {
            const item = PREMIUM_UPGRADES.find(i => i.id === id);
            if (!item) return;

            let cost = 0;
            if (id === 'p1') cost = item.costPt;
            else if (id === 'p2') cost = Math.pow(2, extraRobotCount);
            else if (id === 'p3') cost = item.costPt;
            else if (id === 'p4') cost = item.costPt;
            else if (id === 'p5') cost = item.costPt;
            else if (id === 'p6') {
                const costs = [4, 6, 8];
                cost = costs[massProductionCount];
            } else if (id === 'p7') cost = item.costPt;
            else if (id === 'p8') cost = item.costPt;
            else if (id === 'p9') cost = item.costPt;
            else if (id === 'p10') cost = item.costPt;
            // â˜…è¿½åŠ 
            else if (id === 'p11') cost = item.costPt;
            else if (id === 'p12') cost = item.costPt;
            else if (id === 'p13') cost = item.costPt;
            else if (id === 'p14') {
                cost = Math.ceil(8 * Math.pow(1.5, infiniteRobotAddCount));
            }

            if (premiumPoints < cost) return;

            if (id === 'p1') {
                premiumPoints -= cost;
                isPremiumUnlocked = true;
                alert("ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚³ãƒ¼ã‚¹è§£æ”¾ï¼\né€šå¸¸ã‚·ãƒ§ãƒƒãƒ—ã«å¼·åŠ›ãªã‚¢ã‚¤ãƒ†ãƒ ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚");
            } else if (id === 'p2') {
                if (extraRobotCount >= 3) return;
                premiumPoints -= cost;
                extraRobotCount++;
                addRobot(); 
            } else if (id === 'p3') {
                premiumPoints -= cost;
                isInfiniteUnlocked = true;
                alert("é™ç•Œçªç ´ï¼\nã‚·ãƒ§ãƒƒãƒ—ã«ã€Œãƒšãƒ¼ã‚¸5ã€ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚");
            } else if (id === 'p4') {
                premiumPoints -= cost;
                isRobotAIUnlocked = true;
                alert("ãŠæƒé™¤AIæ­è¼‰å®Œäº†ï¼");
            } else if (id === 'p5') {
                premiumPoints -= cost;
                isAutoHoverClickUnlocked = true;
                alert("ã‚¯ãƒªãƒƒã‚¯ä»£è¡Œã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ï¼\nã“ã‚Œã‚ˆã‚Šãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã‚·ãƒ§ãƒƒãƒ—ã®ãƒšãƒ¼ã‚¸2ãŒè§£æ”¾ã•ã‚Œã¾ã™ã€‚");
            } else if (id === 'p6') {
                if (massProductionCount >= 3) return;
                premiumPoints -= cost;
                massProductionCount++;
                addRobot(); 
                addRobot(); 
                alert(`ãƒ­ãƒœãƒƒãƒˆéƒ¨éšŠåˆ°ç€ï¼\nç¾åœ¨ã®ç”Ÿç”£ãƒ¬ãƒ™ãƒ«: ${massProductionCount}/3`);
            } else if (id === 'p7') {
                premiumPoints -= cost;
                isPlasmaUnlocked = true;
                alert("ãƒ—ãƒ©ã‚ºãƒã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ï¼\nãƒ­ãƒœãƒƒãƒˆåŒå£«ãŒé€£æºã—ã¦æ±šã‚Œã‚’ç„¼ãæ‰•ã„ã¾ã™ï¼");
            } else if (id === 'p8') {
                premiumPoints -= cost;
                isAutoProgressUnlocked = true;
                alert("è‡ªå‹•é€²è¡Œãƒ¢ãƒ¼ãƒ‰ON\nã‚¯ãƒªã‚¢ç”»é¢ãŒè‡ªå‹•çš„ã«ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚");
            } else if (id === 'p9') {
                premiumPoints -= cost;
                isPurificationUnlocked = true;
                alert("æµ„åŒ–ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ï¼\né€²è¡Œç‡98%ã§æ®‹ã‚Šã®æ±šã‚Œã‚’æ¶ˆæ»…ã•ã›ã¾ã™ã€‚");
            } else if (id === 'p10') {
                premiumPoints -= cost;
                isColorPaletteUnlocked = true;
                alert("ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆè§£æ”¾ï¼\nç”»é¢å³ä¸‹ã‹ã‚‰æ±šã‚Œã®è‰²ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚");
            }
            // â˜…è¿½åŠ : ãƒšãƒ¼ã‚¸3ã®è³¼å…¥å‡¦ç†
            else if (id === 'p11') {
                premiumPoints -= cost;
                isPlasmaBoostUnlocked = true;
                alert("ãƒ—ãƒ©ã‚ºãƒå‡ºåŠ›å¼·åŒ–ï¼\n3ä½“ä»¥ä¸Šã®ãƒ­ãƒœãƒƒãƒˆãŒã„ã‚‹å ´åˆã€2æœ¬ã®ãƒ“ãƒ¼ãƒ ã§é€£æºã—ã¾ã™ï¼");
            }
            else if (id === 'p12') {
                premiumPoints -= cost;
                isRobotMassProduction5Unlocked = true;
                // ä¸€æ°—ã«5ä½“è¿½åŠ 
                for(let k=0; k<5; k++) addRobot();
                alert("å¤§è¦æ¨¡å¢—ç”£å®Œäº†ï¼\nãƒ­ãƒœãƒƒãƒˆãŒ5ä½“è¿½åŠ ã•ã‚Œã¾ã—ãŸï¼");
            }
            else if (id === 'p13') {
                premiumPoints -= cost;
                isGamingRobotUnlocked = true;
                updateGamingLook(); // å³åº§ã«è¦‹ãŸç›®ã‚’åæ˜ 
                alert("ã‚²ãƒ¼ãƒŸãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ONï¼\nãƒ­ãƒœãƒƒãƒˆãŒä¸ƒè‰²ã«è¼ãå§‹ã‚ã¾ã—ãŸï¼");
            }
            else if (id === 'p14') {
                premiumPoints -= cost;
                infiniteRobotAddCount++;
                addRobot();
                // é€£ç¶šè³¼å…¥ã—ã‚„ã™ã„ã‚ˆã†ã«ã‚¢ãƒ©ãƒ¼ãƒˆã¯å‡ºã•ãšã€éŸ³ã ã‘é³´ã‚‰ã™ã®ãŒã‚ªã‚¹ã‚¹ãƒ¡ã§ã™
                // alert("ãƒ­ãƒœãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã—ãŸï¼"); 
            }

            updatePremiumShop();
            updateUI();
            saveGame();
        };

        closeModalBtns.forEach(btn => {
            btn.addEventListener('click', closeAllModals);
        });
        overlay.addEventListener('click', closeAllModals);

        resetDataBtn.addEventListener('click', () => {
            if (confirm("æœ¬å½“ã«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚")) {
                isResetting = true;
                localStorage.removeItem(SAVE_KEY);
                location.reload();
            }
        });
        
        resetZoomBtn.addEventListener('click', () => {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
            updateUI();
        });

        prevPageBtn.addEventListener('click', () => {
            if (currentShopPage > 1) {
                upgradeListEl.innerHTML = ''; 
                currentShopPage--;
                updateShopList(true);
            }
        });
        nextPageBtn.addEventListener('click', () => {
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);
            if (currentShopPage < maxPage) {
                upgradeListEl.innerHTML = ''; 
                currentShopPage++;
                updateShopList(true);
            }
        });

        upgradeListEl.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                // â˜…è¿½åŠ : ç„¡é™å¼·åŒ–ãƒœã‚¿ãƒ³ã®åˆ¤å®š
                if (e.target.classList.contains('infinite-buy-btn')) {
                    const type = e.target.dataset.type;
                    const cost = parseInt(e.target.dataset.cost);
                    buyInfiniteItem(type, cost);
                    return;
                }
                
                // é€šå¸¸ã‚¢ã‚¤ãƒ†ãƒ ã®åˆ¤å®š
                const id = parseInt(e.target.dataset.id);
                if (!isNaN(id)) {
                    const item = ALL_UPGRADES.find(u => u.id === id);
                    if (item) buyItem(item);
                }
            }
        });

        gameContainer.addEventListener('mousedown', (e) => {
            if (overlay.style.display === 'block') return;
            if (e.button === 2 && isZoomUnlocked) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'move';
                return;
            }
            if (e.button === 0) {
                isMouseDown = true;
                currentSecondClicks++;
                statTotalClicks++;
                
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                attemptClean(e.clientX, e.clientY);
                
                if (autoClickRate > 0) startAutoClick();
            }
        });

        gameContainer.addEventListener('mousemove', (e) => {
            currentMouseX = e.clientX;
            currentMouseY = e.clientY;
            
            // å³ã‚¯ãƒªãƒƒã‚¯ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆè¦–ç‚¹ç§»å‹•ï¼‰ã®å‡¦ç†
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx;
                panY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                clampPan();
                applyTransform();
                return;
            }

            // è‡ªå‹•ãƒ›ãƒãƒ¼ã‚¯ãƒªãƒƒã‚¯ã®å‡¦ç†
            if (isAutoHoverClickUnlocked && !isMouseDown) {
                isMouseDown = true;
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                if (autoClickRate > 0) startAutoClick();
            }

            if (isMouseDown && isDragCleanUnlocked) {
                const dx = e.clientX - lastCleanX;
                const dy = e.clientY - lastCleanY;
                const dist = Math.hypot(dx, dy);
                
                let currentRadius = 1;
                if (brushLevel <= 3) {
                    currentRadius = (brushLevel === 0) ? 1 : 2; 
                } else {
                    currentRadius = 2 + (brushLevel - 3);
                    if (brushLevel >= 9) currentRadius += 5;
                    currentRadius += (infiniteBrushCount * 4);
                }


                const stepSize = Math.max(1, currentRadius / 2);
                const steps = Math.ceil(dist / stepSize);
                
                for (let i = 0; i <= steps; i++) {
                    const t = (steps === 0) ? 1 : i / steps;
                    const interpX = lastCleanX + dx * t;
                    const interpY = lastCleanY + dy * t;
                    attemptClean(interpX, interpY);
                }

                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
            }
        });

        gameContainer.addEventListener('mouseup', (e) => {
            if (e.button === 0) { 
                if (!isAutoHoverClickUnlocked) {
                    isMouseDown = false; 
                    stopAutoClick(); 
                }
            }
            if (isDragging) { isDragging = false; canvas.style.cursor = 'crosshair'; }
        });

        gameContainer.addEventListener('mouseleave', (e) => {
            isMouseDown = false;
            stopAutoClick();
            if (isDragging) { isDragging = false; canvas.style.cursor = 'crosshair'; }
        });

        gameContainer.addEventListener('wheel', (e) => {
            if (!isZoomUnlocked) return;
            e.preventDefault();
            const rect = gameContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldX = (mouseX - panX) / zoomLevel;
            const worldY = (mouseY - panY) / zoomLevel;
            const delta = -Math.sign(e.deltaY) * 0.1;
            let newZoom = zoomLevel + delta;
            newZoom = Math.max(1.0, Math.min(3.0, newZoom));
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                panX = mouseX - worldX * zoomLevel;
                panY = mouseY - worldY * zoomLevel;
                clampPan();
                applyTransform();
                updateUI();
            }
        }, { passive: false });

        gameContainer.addEventListener('contextmenu', (e) => e.preventDefault());

        gameContainer.addEventListener('mouseenter', (e) => {
            if (isAutoHoverClickUnlocked) {
                isMouseDown = true;
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                if (autoClickRate > 0) startAutoClick();
            }
        });
       

        const victoryModal = document.getElementById('victory-modal');
        const autoProgressMsg = document.getElementById('auto-progress-msg');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiAnimId = null;
        let particles = [];

        function resizeConfetti() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeConfetti);

        class Particle {
            constructor() {
                this.x = Math.random() * confettiCanvas.width;
                this.y = Math.random() * confettiCanvas.height - confettiCanvas.height;
                this.size = Math.random() * 10 + 5;
                this.speedY = Math.random() * 3 + 2;
                this.speedX = Math.random() * 2 - 1;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = Math.random() * 10 - 5;
            }
            update() {
                this.y += this.speedY;
                this.x += this.speedX;
                this.rotation += this.rotationSpeed;
                if (this.y > confettiCanvas.height) {
                    this.y = -10;
                    this.x = Math.random() * confettiCanvas.width;
                }
            }
            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate(this.rotation * Math.PI / 180);
                confettiCtx.fillStyle = this.color;
                confettiCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                confettiCtx.restore();
            }
        }

        function startConfetti() {
            resizeConfetti();
            particles = [];
            for (let i = 0; i < 150; i++) { 
                particles.push(new Particle());
            }
            animateConfetti();
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            confettiAnimId = requestAnimationFrame(animateConfetti);
        }

        function stopConfetti() {
            if (confettiAnimId) cancelAnimationFrame(confettiAnimId);
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        }

        function checkVictory() {
            if (hasWon) return; 
            
            if (cleanedCount >= TOTAL_PIXELS) {
                hasWon = true;
                sound.playVictory();
                
                // è¦ç´ ã®å–å¾—
                const h1 = victoryModal.querySelector('h1');
                const pSub = victoryModal.querySelector('.victory-content p'); // "CLICK TO CLOSE"ã®éƒ¨åˆ†
                const msg = document.getElementById('auto-progress-msg');

                // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸100 (cycleCount 99) ã‚¯ãƒªã‚¢æ™‚ã®ç‰¹åˆ¥æ¼”å‡º
                if (cycleCount === 99) {
                    victoryModal.style.display = 'flex';
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è±ªè¯ç‰ˆã«å¤‰æ›´
                    h1.textContent = "GAME CLEAR!!";
                    h1.className = "blink-text true-ending-title"; // è±ªè¯CSSã‚¯ãƒ©ã‚¹ã‚’é©ç”¨
                    
                    pSub.textContent = "THANK YOU FOR PLAYING";
                    pSub.className = "true-ending-sub";

                    // ç´™å¹é›ªé–‹å§‹
                    startConfetti();

                    // â˜…é‡è¦: è‡ªå‹•é€²è¡Œã‚’å¼·åˆ¶çš„ã«ç„¡åŠ¹åŒ–ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚éè¡¨ç¤ºï¼‰
                    msg.style.display = 'none';

                    // ã“ã“ã§å‡¦ç†ã‚’çµ‚äº†ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å¾…ã¤
                    return;
                }

                // --- é€šå¸¸ã®ã‚¯ãƒªã‚¢å‡¦ç† ---
                victoryModal.style.display = 'flex';
                
                // é€šå¸¸ã‚¹ã‚¿ã‚¤ãƒ«ã«æˆ»ã™ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰
                h1.textContent = "CONGRATULATIONS";
                h1.className = "blink-text"; 
                pSub.textContent = "CLICK TO CLOSE";
                pSub.className = "";

                startConfetti();

                if (isAutoProgressUnlocked) {
                    msg.style.display = 'block';
                    setTimeout(() => {
                        // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒã¾ã é–‹ã„ã¦ã„ã‚Œã°è‡ªå‹•ã§é–‰ã˜ã‚‹
                        if (victoryModal.style.display !== 'none') {
                            victoryModal.style.display = 'none';
                            stopConfetti();
                            resetBoard();
                        }
                    }, 1000);
                } else {
                    msg.style.display = 'none';
                }
            }
        }

        victoryModal.addEventListener('click', () => {
            victoryModal.style.display = 'none';
            stopConfetti();
            resetBoard();
        });

        prevPremiumPageBtn.addEventListener('click', () => {
            if (currentPremiumPage > 1) {
                currentPremiumPage--;
                updatePremiumShop();
            }
        });
        
        nextPremiumPageBtn.addEventListener('click', () => {
            const isPage2Complete = (massProductionCount >= 3 && isPlasmaUnlocked && isAutoProgressUnlocked && isPurificationUnlocked && isColorPaletteUnlocked);
            let maxPage = 1;
            if (isAutoHoverClickUnlocked) maxPage = 2;
            if (isPage2Complete) maxPage = 3;

            if (currentPremiumPage < maxPage) {
                currentPremiumPage++;
                updatePremiumShop();
            }
        });
        
        premiumBtn.addEventListener('click', () => {
            updatePremiumShop();
            openModal(premiumModal);
        });

        dirtColorPicker.addEventListener('input', (e) => {
            if (!isColorPaletteUnlocked) return;
            dirtColor = e.target.value;
            canvas.style.backgroundColor = dirtColor;
        });

        function redrawBoard() {
            ctx.fillStyle = dirtColor;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = '#000000';
            cleanedPixels.forEach(idx => {
                const y = Math.floor(idx / WIDTH);
                const x = idx % WIDTH;
                ctx.fillRect(x, y, 1, 1);
            });
        }

        function resetBoard() {
            cycleCount++;
            premiumPoints++; 
            
            cleanedCount = 0;
            cleanedPixels.clear();
            hasWon = false;

            canvas.style.backgroundColor = dirtColor; 
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            hintBoxEl.style.display = 'none';
            hintTargetIndex = -1;

            updateUI();
            
            cycleCountEl.classList.remove('flash-active');
            void cycleCountEl.offsetWidth; 
            cycleCountEl.classList.add('flash-active');
            
            saveGame();
        }

        const soundBtn = document.getElementById('sound-toggle-btn');
        soundBtn.addEventListener('click', () => {
            const isEnabled = sound.toggle();
            soundBtn.textContent = isEnabled ? "SOUND: ON" : "SOUND: OFF";
            soundBtn.style.color = isEnabled ? "#0f0" : "#fff";
            soundBtn.style.borderColor = isEnabled ? "#0f0" : "#fff";
        });

        function gameLoop(timestamp) {
		    // åˆå›å®Ÿè¡Œæ™‚ã®æ™‚é–“èª¿æ•´
		    if (!lastFrameTime) lastFrameTime = timestamp;
		    
		    // å‰å›ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆç§’ï¼‰ã‚’è¨ˆç®—
		    const deltaTime = (timestamp - lastFrameTime) / 1000;
		    lastFrameTime = timestamp;

		    updateRobots();
		    updatePlasma(); 
		    updatePurification(); 
		    renderEntities();
		    updateHint();

		    // --- è‡ªå‹•ã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã®æœ€é©åŒ–ç‰ˆ ---
		    if (isMouseDown && autoClickRate > 0) {
		        // çµŒéæ™‚é–“ Ã— é€Ÿåº¦ åˆ†ã®ã‚¯ãƒªãƒƒã‚¯å›æ•°ã‚’è²¯ã‚ã‚‹
		        autoClickAccumulator += autoClickRate * deltaTime;

		        // 1å›åˆ†ä»¥ä¸Šè²¯ã¾ã£ã¦ã„ãŸã‚‰å®Ÿè¡Œ
		        // â€»ã€Œãƒã‚¦ã‚¹ä½ç½®ãŒå¤‰ã‚ã£ã¦ã„ãªã„ã®ã«ä½•åº¦ã‚‚æç”»ã™ã‚‹ã€ç„¡é§„ã‚’é˜²ããŸã‚ã€
		        //   ãƒ«ãƒ¼ãƒ—ã¯ã•ã›ãšã€è²¯ã¾ã£ã¦ã„ã‚‹åˆ†ã‚’1å›ã ã‘å®Ÿè¡Œã—ã¦æ¶ˆè²»ã—ã¾ã™ã€‚
		        //   ï¼ˆã“ã®ã‚²ãƒ¼ãƒ ã®ä»•æ§˜ä¸Šã€åŒã˜å ´æ‰€ã‚’é€£æ‰“ã—ã¦ã‚‚æ„å‘³ãŒãªã„ãŸã‚ã“ã‚Œã§è»½é‡åŒ–ã•ã‚Œã¾ã™ï¼‰
		        if (autoClickAccumulator >= 1) {
		            attemptClean(currentMouseX, currentMouseY);
		            
		            // è²¯ã¾ã£ãŸåˆ†ã‚’æ¶ˆè²»ï¼ˆä½™å‰°åˆ†ã¯æ¬¡å›ã«æŒã¡è¶Šã—ï¼‰
		            // ãŸã ã—ã€æ¥µç«¯ã«æºœã¾ã‚Šã™ããŸå ´åˆï¼ˆãƒ©ã‚°ãªã©ï¼‰ã¯ãƒªã‚»ãƒƒãƒˆã—ã¦ãƒ•ãƒªãƒ¼ã‚ºã‚’é˜²ã
		            if (autoClickAccumulator > 5) {
		                 autoClickAccumulator = 0;
		            } else {
		                 autoClickAccumulator -= 1;
		            }
		        }
		    } else {
		        // ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã„ãªã„æ™‚ã¯ãƒªã‚»ãƒƒãƒˆ
		        autoClickAccumulator = 0;
		    }
		    // ----------------------------------
		    
		    if (timestamp - lastUIUpdate > 33) {
		        updateUI();
		        lastUIUpdate = timestamp;
		    }
		    requestAnimationFrame(gameLoop);
		}
    </script>
</body>
</html>