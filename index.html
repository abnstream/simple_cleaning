<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Cleaning Game</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Courier New', monospace;
            user-select: none;
            overflow: hidden;
        }

       /* --- UI周り --- */
        #ui-bar {
            width: 1280px;
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* 左・中央・右 の3分割 */
            align-items: center;
            margin-bottom: 10px;
            position: relative;
        }

        /* 左エリア */
        #top-left-info {
            grid-column: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        /* ... (中略: #cycle-container などのスタイルはそのまま) ... */

        /* ★変更: 中央エリア (統計 + 進行率) */
        #center-panel {
            grid-column: 2;
            display: flex;
            align-items: center;
            gap: 20px; /* ボタンと進行率の間隔 */
        }

        #progress-container {
            /* grid-column: 2; を削除 */
            text-align: center;
            font-size: 32px;
            font-weight: bold;
        }

        /* 右エリア */
        #right-panel {
            grid-column: 3;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }

        #cycle-container {
            font-size: 24px;
            font-weight: bold;
            font-family: 'Impact', sans-serif;
            letter-spacing: 1px;
        }

        .cycle-text {
            color: #fff;
        }
        .cycle-limit {
            color: #666;
            font-size: 0.8em;
        }

        /* 数字が光るアニメーション */
        @keyframes flashAnim {
            0% { color: #fff; text-shadow: none; transform: scale(1); }
            50% { color: #00ff00; text-shadow: 0 0 20px #00ff00, 0 0 40px #fff; transform: scale(1.5); }
            100% { color: #fff; text-shadow: none; transform: scale(1); }
        }
        .flash-active {
            animation: flashAnim 1.0s ease-out forwards;
        }

        #premium-btn {
            background: linear-gradient(135deg, #b8860b, #ffd700);
            color: #000;
            border: 1px solid #fff;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            padding: 5px 15px;
        }
        #premium-btn:hover {
            background: linear-gradient(135deg, #ffd700, #ffec8b);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #ppt-container {
            color: #ffd700;
            font-weight: bold;
            font-size: 18px;
        }

        #progress-container {
            grid-column: 2;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
        }

        #right-panel {
            grid-column: 3;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
        }

        #money-container {
            font-size: 20px;
            min-width: 150px;
            text-align: right;
            margin-left: 10px;
        }

        button {
            background-color: #333;
            color: #fff;
            border: 1px solid #fff;
            padding: 5px 15px;
            font-family: inherit;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.1s, opacity 0.1s;
        }
        button:hover {
            background-color: #555;
        }
        button:disabled {
            background-color: #222;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }
        button:active {
            transform: translateY(1px);
        }

        #settings-btn {
            padding: 5px 10px;
            font-size: 0.9em;
        }

        #hint-box {
            position: absolute;
            border: 2px solid #ff0000;
            box-shadow: 0 0 4px #ff0000, inset 0 0 4px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 5;
            box-sizing: border-box;
        }

        /* --- ゲーム表示エリア --- */
        #game-container {
            width: 1280px;
            height: 720px;
            border: 1px solid #fff;
            position: relative;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            background-color: #000;
            image-rendering: pixelated; 
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            z-index: 1; 
        }

        #entity-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 2; 
        }

        .robot {
            position: absolute;
            background-color: #ff3333; 
            box-shadow: 0 0 4px #ff0000;
            width: 1px;
            height: 1px;
        }

        /* ★追加: ゲーミングロボット用アニメーション */
        @keyframes rainbow {
            0% { background-color: #ff0000; box-shadow: 0 0 8px #ff0000; }
            15% { background-color: #ff00ff; box-shadow: 0 0 8px #ff00ff; }
            30% { background-color: #0000ff; box-shadow: 0 0 8px #0000ff; }
            45% { background-color: #00ffff; box-shadow: 0 0 8px #00ffff; }
            60% { background-color: #00ff00; box-shadow: 0 0 8px #00ff00; }
            75% { background-color: #ffff00; box-shadow: 0 0 8px #ffff00; }
            100% { background-color: #ff0000; box-shadow: 0 0 8px #ff0000; }
        }
        .robot.gaming {
            animation: rainbow 0.5s linear infinite;
        }

        /* プラズマエフェクト */
        .plasma-beam {
            position: absolute;
            /* 変更: 原色の水色から、半透明の淡いブルーに変更 */
            background-color: rgba(173, 216, 230, 0.4); 
            
            /* 変更: ギラギラした発光(box-shadow)を弱く、柔らかくする */
            box-shadow: 0 0 4px rgba(173, 216, 230, 0.5), 0 0 8px rgba(255, 255, 255, 0.3);
            
            transform-origin: 0 50%;
            opacity: 1;
            transition: opacity 0.8s ease-out;
            z-index: 5;
            border-radius: 999px;
            
            /* 追加: 輪郭をぼかしてさらに柔らかく */
            filter: blur(1px);
        }

        /* --- 下部情報エリア --- */
        #bottom-info {
            width: 1280px;
            height: 30px;
            margin-top: 5px;
            display: flex;
            align-items: center; 
            gap: 20px; 
        }

        #zoom-control-area {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #zoom-indicator {
            color: #0f0;
            font-weight: bold;
            display: none; 
        }

        #reset-zoom-btn {
            padding: 2px 8px;
            font-size: 0.8em;
            background-color: #444;
            border-color: #888;
            display: none; 
        }
        #reset-zoom-btn:hover {
            background-color: #666;
        }

        #save-status {
            color: #aaa;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* --- モーダル (共通) --- */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #000;
            border: 2px solid #fff;
            padding: 20px;
            width: 500px;
            height: 500px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            flex-direction: column;
        }
        
        .modal-content {
            flex: 1;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #fff;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .modal-header h2 {
            margin: 0;
        }
        .page-indicator {
            font-size: 1.2em;
            font-weight: bold;
        }

        .modal-footer {
            margin-top: auto; 
            padding-top: 15px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pagination-controls {
            display: flex;
            gap: 10px;
        }
        .pagination-controls button {
            width: 40px;
            padding: 5px 0;
            text-align: center;
        }

        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #444;
        }
        
        .upgrade-item.purchased {
            border-color: #333;
            color: #999; 
            background-color: #111;
        }
        
        .upgrade-item.next-up {
            border-color: #fff;
            background-color: #000;
        }

        .upgrade-info div:first-child {
            font-weight: bold;
            font-size: 1.1em;
        }
        .upgrade-info div:last-child {
            font-size: 0.8em;
            color: #aaa;
        }
        .upgrade-item.purchased .upgrade-info div:last-child {
            color: #555;
        }

        .status-text {
            font-weight: bold;
            color: #0f0;
            padding: 5px 10px;
        }

        .action-part {
            min-width: 120px;
            text-align: right;
        }

        .danger-zone {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #444;
            text-align: center;
        }
        #reset-data-btn {
            background-color: #300;
            border-color: #f00;
            color: #fdd;
        }
        #reset-data-btn:hover {
            background-color: #500;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 99;
        }

        /* --- 通知バッジ用スタイル --- */
        #shop-btn {
            position: relative; 
            overflow: visible;
        }

        #shop-btn.has-notification::after {
            content: "!";
            position: absolute;
            top: -10px;   
            right: -10px; 
            width: 24px;
            height: 24px;
            background-color: #ff0000; 
            color: #ffff00;            
            border-radius: 50%;        
            text-align: center;
            line-height: 24px;         
            font-weight: bold;
            font-size: 18px;
            border: 2px solid #fff;    
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            pointer-events: none;      
            z-index: 10;
        }

        /* --- クリア画面用 --- */
        #victory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
        }

        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .victory-content {
            position: relative;
            z-index: 2001;
            text-align: center;
        }

        .victory-content h1 {
            color: #ffff00;
            font-size: 80px;
            margin: 0;
            text-shadow: 0 0 20px #ffaa00;
            font-family: 'Arial', sans-serif;
            letter-spacing: 5px;
        }
        
        .victory-content p {
            color: #ff3333;
            font-size: 24px;
            margin-top: 20px;
            cursor: pointer;
            font-weight: bold;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .blink-text {
            animation: blink 1s infinite;
        }

        /* --- プレミアムモーダル --- */
        .premium-item {
            border: 1px solid #ffd700;
            padding: 15px;
            margin-bottom: 10px;
            background-color: #221a00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .premium-item button {
            background-color: #b8860b;
            color: #000;
            border-color: #ffd700;
        }
        .premium-item.purchased {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        /* --- カラーパレット (右下) --- */
        #color-palette-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: none; /* 解放されるまで非表示 */
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #fff;
        }
        #dirt-color-picker {
            width: 50px;
            height: 50px;
            cursor: pointer;
            border: 2px solid #fff;
            background: none;
            padding: 0;
        }
        #palette-label {
            font-size: 12px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        /* --- 豪華なクリア画面用CSS (Stage 100) --- */
        .true-ending-title {
            background: linear-gradient(135deg, #bf953f, #fcf6ba, #b38728, #fbf5b7, #aa771c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #d4af37;
            font-family: 'Times New Roman', serif; /* 明朝体系で高級感を出す */
            text-shadow: 0px 0px 50px rgba(255, 215, 0, 0.8);
            font-size: 110px !important;
            letter-spacing: 15px !important;
            transform: scale(1.1);
        }
        
        .true-ending-sub {
            color: #fff !important;
            font-family: serif;
            text-shadow: 0 0 20px #ffd700;
            font-size: 30px !important;
            letter-spacing: 5px;
            margin-top: 20px !important;
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div id="top-left-info" style="display: none;">
            <div id="cycle-container">
                <span id="cycle-count" class="cycle-text">001</span><span class="cycle-limit">/100</span>
            </div>
            <button id="premium-btn">プレミアム</button>
            <div id="ppt-container">P.Pt <span id="ppt-val">0</span></div>
        </div>

        <div id="center-panel">
            <button id="settings-btn">統計</button>
            <div id="progress-container">
                進行率: <span id="progress">00.00</span>%
            </div>
        </div>

        <div id="right-panel">
            <button id="shop-btn">ショップ</button>
            <div id="money-container">
                所持金: <span id="money">0</span> G
            </div>
            <button id="sound-toggle-btn">SOUND: OFF</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="1280" height="720"></canvas>
        <div id="entity-layer">
            <div id="hint-box"></div> </div>
    </div>

    <div id="bottom-info">
        <div id="zoom-control-area">
            <span id="zoom-indicator">ZOOM x<span id="zoom-val">1.0</span></span>
            <button id="reset-zoom-btn">Reset</button>
        </div>
        <div id="save-status">Auto Saving...</div>
    </div>

    <div id="overlay"></div>

    <div id="spam-modal" class="modal" style="display: none; height: auto; border-color: #ff0000;">
        <div class="modal-header" style="border-bottom-color: #ff0000;">
            <h2 style="color: #ff0000;">WARNING</h2>
        </div>
        <div class="modal-content" style="text-align: center; padding: 20px 0;">
            <p style="font-size: 1.2em; margin-bottom: 20px;">
                連打ツール使ってない？<br>
                フェアに行こうよ
            </p>
        </div>
        <div class="modal-footer" style="justify-content: center; border-top-color: #555;">
            <button id="spam-ok-btn" style="width: 100px; border-color: #ff0000; color: #ffcccc;">OK</button>
        </div>
    </div>

    <div id="shop-modal" class="modal" style="display: none;">
        <div class="modal-header">
            <h2>アップグレード</h2>
            <div class="page-indicator"><span id="page-num">1</span>/<span id="page-max">4</span></div>
        </div>
        
        <div id="upgrade-list" class="modal-content">
            </div>
        
        <div class="modal-footer">
            <div class="pagination-controls" id="shop-pagination">
                <button id="prev-page-btn">←</button>
                <button id="next-page-btn">→</button>
            </div>
            <button class="close-modal">閉じる</button>
        </div>
    </div>

    <div id="premium-modal" class="modal" style="display: none; border-color: #ffd700;">
        <div class="modal-header" style="border-bottom-color: #ffd700;">
            <h2 style="color: #ffd700;">プレミアムアップグレード</h2>
            <div style="color: #ffd700;">所持 P.Pt: <span id="modal-ppt-val">0</span></div>
            <div class="page-indicator" style="font-size: 0.8em; color: #ffd700;">
                <span id="premium-page-num">1</span>/<span id="premium-page-max">1</span>
            </div>
        </div>
        <div id="premium-list" class="modal-content">
            </div>
        <div class="modal-footer" style="border-top-color: #555; justify-content: space-between;">
            <div class="pagination-controls" id="premium-pagination" style="display:none;">
                <button id="prev-premium-page-btn">←</button>
                <button id="next-premium-page-btn">→</button>
            </div>
            <button class="close-modal">閉じる</button>
        </div>
    </div>

    <div id="settings-modal" class="modal" style="display: none; height: auto;">
        <div class="modal-header">
            <h2>統計</h2>
        </div>
        <div class="modal-content">
            <div style="margin-bottom: 20px; line-height: 1.8;">
                <div>クリックした回数: <span id="stat-clicks" style="font-weight:bold;">0</span> 回</div>
                <div>クリックで掃除したピクセル: <span id="stat-click-cleaned" style="font-weight:bold;">0</span> 個</div>
                <div>ロボット掃除機が掃除したピクセル: <span id="stat-robot-cleaned" style="font-weight:bold;">0</span> 個</div>
                <div>連打ツール警告回数: <span id="stat-spam-warnings" style="font-weight:bold;">0</span> 回</div>
            </div>

            <hr style="border: 0; border-top: 1px solid #444; margin: 15px 0;">

            <p style="font-size: 0.9em; color: #aaa;">ゲームの進行状況は自動で保存されています。</p>
            
            <div class="danger-zone">
                <p>※進行状況を完全にリセットします</p>
                <button id="reset-data-btn">データリセット</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: flex-end;">
            <button class="close-modal">閉じる</button>
        </div>
    </div>

    <div id="victory-modal" style="display: none;">
        <canvas id="confetti-canvas"></canvas>
        <div class="victory-content">
            <h1 class="blink-text">CONGRATULATIONS</h1>
            <p>CLICK TO CLOSE</p>
            <p id="auto-progress-msg" style="font-size:16px; color:#aaa; display:none;">Auto Progress in 1s...</p>
        </div>
    </div>

    <div id="color-palette-container">
        <label id="palette-label" for="dirt-color-picker">DIRT COLOR</label>
        <input type="color" id="dirt-color-picker" value="#87CEEB">
    </div>

    <script>

        // --- Sound Manager (Web Audio API) ---
        class SoundManager {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.isEnabled = false;
            this.cleanBuffer = null;
        }

        init() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = 0.1; // 全体の音量
            
            // ノイズバッファの生成（掃除音用）
            const bufferSize = this.ctx.sampleRate * 2.0; // 2秒分
            this.cleanBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = this.cleanBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        }

        toggle() {
            this.isEnabled = !this.isEnabled;
            if (this.isEnabled && !this.ctx) this.init();
            if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            return this.isEnabled;
        }

        playTone(freq, type, duration, vol = 1.0) {
            if (!this.isEnabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }

        // 掃除音（ザザッ）
        playClean() {
            if (!this.isEnabled || !this.ctx) return;
            // 連続再生されすぎないように少しランダムにピッチを変える
            const src = this.ctx.createBufferSource();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();

            src.buffer = this.cleanBuffer;
            src.loop = true;
            // 再生速度を変えて音程を変化させる
            src.playbackRate.value = 0.8 + Math.random() * 0.4;

            filter.type = 'lowpass';
            filter.frequency.value = 800;

            gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);

            src.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            
            src.start();
            src.stop(this.ctx.currentTime + 0.1);
        }

        // 購入音（チャリーン）
        playBuy() {
            if (!this.isEnabled) return;
            this.playTone(1200, 'sine', 0.1, 0.5);
            setTimeout(() => this.playTone(1800, 'sine', 0.4, 0.5), 50);
        }

        // エラー/警告音（ブブー）
        playError() {
            if (!this.isEnabled) return;
            this.playTone(150, 'sawtooth', 0.3, 0.5);
        }

        // プラズマ発射音（ビュン！）
        playPlasma() {
            if (!this.isEnabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);
            
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.3);
        }

        // クリアファンファーレ
        playVictory() {
            if (!this.isEnabled) return;
            const now = this.ctx.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; // C E G C G C
            const times = [0, 0.1, 0.2, 0.3, 0.4, 0.6];
            const lens  = [0.1, 0.1, 0.1, 0.1, 0.2, 0.8];

            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + times[i]);
                gain.gain.setValueAtTime(0.3, now + times[i]);
                gain.gain.exponentialRampToValueAtTime(0.01, now + times[i] + lens[i]);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now + times[i]);
                osc.stop(now + times[i] + lens[i]);
            });
        }
    }
    
    // インスタンス作成
    const sound = new SoundManager();

        // --- 設定・定数 ---
        const WIDTH = 1280;
        const HEIGHT = 720;
        const TOTAL_PIXELS = WIDTH * HEIGHT;
        const SAVE_KEY = 'pixel_cleaner_save_v1';
        
        const ALL_UPGRADES = [
            // Page 1: Basic
            { id: 1, page: 1, type: 'brush', level: 1, cost: 50,   name: "範囲強化 Lv.1", desc: "クリックで掃除できる範囲が広くなる" },
            { id: 2, page: 1, type: 'brush', level: 2, cost: 250,  name: "範囲強化 Lv.2", desc: "クリックで掃除できる範囲がさらに広くなる" },
            { id: 3, page: 1, type: 'brush', level: 3, cost: 1000,  name: "範囲強化 Lv.3", desc: "クリックで掃除できる範囲がもっと広くなる" },
            { id: 4, page: 1, type: 'zoom',  level: 1, cost: 2000, name: "ズーム機能",   desc: "マウスホイールでズームできるようになる" },
            { id: 5, page: 1, type: 'robot', repeatable: false, cost: 2500, name: "ロボット掃除機", desc: "自動お掃除ロボットが手に入る" },
            { id: 21, page: 1, type: 'hint', cost: 50000, name: "汚染センサー", desc: "掃除できてない場所をわかりやすいように強調する", reqProgress: 90 },
            
            // Page 2: Auto Clicker
            { id: 6,  page: 2, type: 'auto_click', rate: 8,  cost: 10000,  name: "小型ハンディクリーナー", desc: "長押しで掃除できるようになる" },
            { id: 7,  page: 2, type: 'auto_click', rate: 12, cost: 20000,  name: "ハンディクリーナー",   desc: "長押しでスムーズに掃除できるようになる" },
            { id: 8,  page: 2, type: 'auto_click', rate: 16, cost: 40000,  name: "サイクロンアタッチメント", desc: "長押しでもっとスムーズに掃除できるようになる" },
            { id: 9,  page: 2, type: 'auto_click', rate: 24, cost: 60000,  name: "ターボモーターヘッド",   desc: "長押しでかなりスムーズに掃除できるようになる" },
            { id: 10, page: 2, type: 'auto_click', rate: 32, cost: 90000, name: "吸引力の変わらないただ一つの", desc: "長押しでとてもスムーズに掃除できるようになる" },
            { id: 22, page: 2, type: 'drag_clean', cost: 300000, name: "マジックブラシ", desc: "素早くマウスを動かしても、隙間なく掃除できるようになる", reqPremium: true },

            // Page 3: Robot Upgrades
            { id: 11, page: 3, type: 'robot_area', level: 1, cost: 10000, name: "自動掃除機範囲強化1", desc: "お掃除ロボットの掃除範囲が広くなる" },
            { id: 12, page: 3, type: 'robot_speed', value: 0.2, cost: 20000, name: "自動掃除機移動速度強化1", desc: "お掃除ロボットの移動速度が上がる" },
            { id: 13, page: 3, type: 'robot_area', level: 2, cost: 40000, name: "自動掃除機範囲強化2", desc: "お掃除ロボットの掃除範囲がさらに広くなる" },
            { id: 14, page: 3, type: 'robot_speed', value: 0.3, cost: 60000, name: "自動掃除機移動速度強化2", desc: "お掃除ロボットの移動速度がさらに上がる" },
            { id: 15, page: 3, type: 'robot_area', level: 3, cost: 90000, name: "自動掃除機範囲強化3", desc: "お掃除ロボットの掃除範囲がもっと広がる" },
            { id: 23, page: 3, type: 'robot_area', level: 4, cost: 300000, name: "自動掃除機範囲強化極", desc: "お掃除ロボットの掃除範囲がかなり広くなる", reqPremium: true },
            
            // Page 4: Brush Extension
            { id: 16, page: 4, type: 'brush', level: 4, cost: 10000,  name: "ブラシサイズ拡張 Lv.1", desc: "クリックで掃除できる範囲が広くなる" },
            { id: 17, page: 4, type: 'brush', level: 5, cost: 20000,  name: "ブラシサイズ拡張 Lv.2", desc: "クリックで掃除できる範囲がさらに広くなる" },
            { id: 18, page: 4, type: 'brush', level: 6, cost: 40000,  name: "ブラシサイズ拡張 Lv.3", desc: "クリックで掃除できる範囲がもっと広くなる" },
            { id: 19, page: 4, type: 'brush', level: 7, cost: 60000,  name: "ワイドノズル",        desc: "クリックで掃除できる範囲がかなり広くなる" },
            { id: 20, page: 4, type: 'brush', level: 8, cost: 90000, name: "ターボワイドノズル",  desc: "クリックで掃除できる範囲がすごく広くなる" },
            { id: 24, page: 4, type: 'brush', level: 9, cost: 300000, name: "ギガワイドノズル", desc: "クリックで掃除できる範囲が圧倒的に広くなる", reqPremium: true }
        ];

        const INFINITE_BASE_COST = 700000;
        const INFINITE_COST_MULT = 1.3;
        const INFINITE_MAX_LEVEL = 10;

        

        const PREMIUM_UPGRADES = [
            // Page 1
            { id: 'p1', page: 1, costPt: 1, name: "プレミアムコース", desc: "ショップに強力なアップグレードを追加します", unique: true },
            { id: 'p2', page: 1, baseCost: 1, name: "ロボット追加", desc: "ロボットを1台追加します (最大3回)", unique: false },
            { id: 'p3', page: 1, costPt: 3, name: "限界突破", desc: "ショップのページ5を解放します", unique: true },
            { id: 'p4', page: 1, costPt: 5, name: "お掃除AI", desc: "お掃除ロボットが反射するときにある程度汚れを狙うようになります", unique: true, reqRobotMax: true },
            { id: 'p5', page: 1, costPt: 5, name: "クリック代行", desc: "画面内にマウスがあるだけで、常にクリックしている状態になります", unique: true, reqAI: true },
            
            // Page 2
            { id: 'p6', page: 2, name: "ロボット量産", desc: "ロボットを2台追加します (最大3回)", unique: false },
            { id: 'p7', page: 2, costPt: 10, name: "プラズマ", desc: "3秒毎にロボット同士が連携し、間の汚れを焼き払います", unique: true, reqMassProductionMax: true },
            { id: 'p8', page: 2, costPt: 5, name: "自動進行", desc: "クリア画面で1秒経過すると、自動で次の周回へ進みます", unique: true, reqMassProductionMax: true },
            { id: 'p9', page: 2, costPt: 5, name: "浄化", desc: "進行率が98%を超えると、残りの汚れを全て消滅させます", unique: true, reqMassProductionMax: true },
            { id: 'p10', page: 2, costPt: 5, name: "カラーパレット", desc: "画面右下に汚れの色を自由に変更できるボタンを追加します", unique: true, reqMassProductionMax: true },

            // ★追加 Page 3
            { id: 'p11', page: 3, costPt: 10, name: "プラズマ強化", desc: "プラズマが最も近いロボットと最も遠いロボットの間で発生します", unique: true },
            { id: 'p12', page: 3, costPt: 10, name: "ロボット大量生産", desc: "ロボットを5体追加します", unique: true },
            { id: 'p13', page: 3, costPt: 10, name: "ゲーミングロボット", desc: "ロボットが虹色に輝くようになります", unique: true }
        ];

        // --- DOM取得 ---
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const entityLayer = document.getElementById('entity-layer');
        const progressEl = document.getElementById('progress');
        const moneyEl = document.getElementById('money');
        const hintBoxEl = document.getElementById('hint-box');
        
        const shopBtn = document.getElementById('shop-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const shopModal = document.getElementById('shop-modal');
        const settingsModal = document.getElementById('settings-modal');
        const overlay = document.getElementById('overlay');
        const closeModalBtns = document.querySelectorAll('.close-modal');
        const upgradeListEl = document.getElementById('upgrade-list');
        const resetDataBtn = document.getElementById('reset-data-btn');

        const zoomIndicator = document.getElementById('zoom-indicator');
        const zoomValEl = document.getElementById('zoom-val');
        const resetZoomBtn = document.getElementById('reset-zoom-btn');
        const saveStatusEl = document.getElementById('save-status');
        
        const pageNumEl = document.getElementById('page-num');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const shopPagination = document.getElementById('shop-pagination');

        const premiumPageNumEl = document.getElementById('premium-page-num');
        const premiumPageMaxEl = document.getElementById('premium-page-max');
        const prevPremiumPageBtn = document.getElementById('prev-premium-page-btn');
        const nextPremiumPageBtn = document.getElementById('next-premium-page-btn');
        const premiumPagination = document.getElementById('premium-pagination');

        // New Info DOM
        const topLeftInfo = document.getElementById('top-left-info');
        const cycleCountEl = document.getElementById('cycle-count');
        const premiumBtn = document.getElementById('premium-btn');
        const pptValEl = document.getElementById('ppt-val');
        
        const premiumModal = document.getElementById('premium-modal');
        const premiumListEl = document.getElementById('premium-list');
        const modalPptValEl = document.getElementById('modal-ppt-val');

        // --- ゲーム状態 ---
        let cleanedCount = 0;
        let money = 0;
        let hasWon = false;
        
        let statTotalClicks = 0;
        let statClickCleaned = 0;
        let statRobotCleaned = 0;
        let statSpamWarnings = 0;
      
        let brushLevel = 0; 
        let isZoomUnlocked = false;
        
        let robots = []; 
        let robotSpeed = 0.1;
        let robotBrushLevel = 0; 

        let autoClickRate = 0; 
        let isMouseDown = false;
        let autoClickIntervalId = null;
        let currentMouseX = 0; 
        let currentMouseY = 0;

        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        let extraRobotCount = 0;      // プレミアムで追加したロボットの数
        let isInfiniteUnlocked = false; // ページ5解放フラグ
        let isRobotAIUnlocked = false;
        let isAutoHoverClickUnlocked = false;

        let autoClickAccumulator = 0; // クリック分を貯める変数
        let lastFrameTime = 0;        // 前回のフレーム時間
        
        // 無限アップグレードの購入数管理
        let infiniteBrushCount = 0;
        let infiniteRobotAreaCount = 0;
        let infiniteRobotSpeedCount = 0;

        let lastCleanX = 0;
        let lastCleanY = 0;

        let cleanedPixels = new Set(); 
        let isResetting = false;
        
        let currentShopPage = 1;
        let lastUIUpdate = 0;

        const SPAM_CPS_THRESHOLD = 25; 
        const SPAM_DURATION_SEC = 3;   
        
        let currentSecondClicks = 0;
        let spamConsecutiveSeconds = 0;
        
        const spamModal = document.getElementById('spam-modal');
        const spamOkBtn = document.getElementById('spam-ok-btn');

        let isHintUnlocked = false; 
        let lastCleanTime = Date.now(); 
        let hintTargetIndex = -1; 

        // 周回・プレミアム関連
        let cycleCount = 0;      
        let premiumPoints = 0;   
        let isPremiumUnlocked = false; 
        let isDragCleanUnlocked = false;

        // プレミアムショップ用変数
        let currentPremiumPage = 1;
        let massProductionCount = 0; // ロボット量産の購入回数
        let isPlasmaUnlocked = false; // プラズマ解放フラグ
        let lastPlasmaTime = 0;
        
        // 自動進行・浄化フラグ
        let isAutoProgressUnlocked = false;
        let isPurificationUnlocked = false;

        // カラーパレット関連変数
        let dirtColor = '#87CEEB'; 
        let isColorPaletteUnlocked = false;
        const dirtColorPicker = document.getElementById('dirt-color-picker');
        const colorPaletteContainer = document.getElementById('color-palette-container');

        // ★追加: ページ3のアイテムフラグ
        let isPlasmaBoostUnlocked = false;
        let isGamingRobotUnlocked = false;
        let isRobotMassProduction5Unlocked = false; // ロボット大量生産(5体)

        // 1秒ごとにクリック数をチェックするタイマー
        setInterval(() => {
            if (spamModal.style.display === 'flex') {
                currentSecondClicks = 0;
                return;
            }

            if (currentSecondClicks >= SPAM_CPS_THRESHOLD) {
                spamConsecutiveSeconds++;
            } else {
                spamConsecutiveSeconds = 0;
            }

            if (spamConsecutiveSeconds >= SPAM_DURATION_SEC) {
                openModal(spamModal);
                sound.playError(); 
                statSpamWarnings++;
                overlay.removeEventListener('click', closeAllModals); 
            }

            currentSecondClicks = 0;
        }, 1000);

        // お仕置き解除ボタン
        spamOkBtn.addEventListener('click', () => {
            closeAllModals();
            spamConsecutiveSeconds = 0;
            currentSecondClicks = 0;
            overlay.addEventListener('click', closeAllModals);
        });

        // --- 初期化 ---
        canvas.style.backgroundColor = dirtColor; // 背景色を汚れの色にする
        ctx.clearRect(0, 0, WIDTH, HEIGHT);       // キャンバス自体は透明にする

        // ===============================================
        //  関数定義
        // ===============================================

        function openModal(modal) {
            modal.style.display = 'flex'; 
            overlay.style.display = 'block';
        }

        function closeAllModals() {
            shopModal.style.display = 'none';
            settingsModal.style.display = 'none';
            spamModal.style.display = 'none';
            premiumModal.style.display = 'none';
            overlay.style.display = 'none';
        }

        function checkPurchased(item) {
            if (!item) return false;
            if (item.type === 'brush') return (brushLevel >= item.level);
            if (item.type === 'zoom') return isZoomUnlocked;
            if (item.type === 'hint') return isHintUnlocked; 
            if (item.type === 'robot') return (robots.length > 0);
            if (item.type === 'auto_click') return (autoClickRate >= item.rate);
            if (item.type === 'robot_area') return (robotBrushLevel >= item.level);
            if (item.type === 'robot_speed') return (robotSpeed >= item.value - 0.001);
            if (item.type === 'drag_clean') return isDragCleanUnlocked;
            if (item.type === 'infinite_brush') return (infiniteBrushCount >= item.level);
            if (item.type === 'infinite_robot_area') return (infiniteRobotAreaCount >= item.level);
            if (item.type === 'infinite_robot_speed') return (infiniteRobotSpeedCount >= item.level);
            return false;
        }

        function hideRemainingItems(items, startIndex) {
            for (let j = startIndex; j < items.length; j++) {
                const domId = `shop-item-${items[j].id}`;
                const el = document.getElementById(domId);
                if (el) el.style.display = 'none';
            }
        }

        function updateShopList(forceRebuild = false) {
            // 最大ページ数の計算
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);

            // ページ数表示の更新
            pageNumEl.textContent = currentShopPage;
            const pageMaxEl = document.getElementById('page-max');
            if (pageMaxEl) pageMaxEl.textContent = maxPage;
            
            if (maxPage > 1) {
                shopPagination.style.display = 'flex';
                prevPageBtn.disabled = (currentShopPage <= 1);
                nextPageBtn.disabled = (currentShopPage >= maxPage);
            } else {
                shopPagination.style.display = 'none';
            }

            if (forceRebuild) upgradeListEl.innerHTML = '';

            // ★修正: ページ5（無限強化）の処理
            // 重複を防ぐため、IDを使って「既に存在するか」をチェックします
            if (currentShopPage === 5) {
                const infinites = [
                    { type: 'infinite_brush', id: 'inf-brush', name: "【限界突破】ブラシ拡張", baseDesc: "ブラシ半径 アップ", count: infiniteBrushCount },
                    { type: 'infinite_robot_area', id: 'inf-area', name: "【限界突破】ロボット範囲", baseDesc: "ロボット掃除半径 アップ", count: infiniteRobotAreaCount },
                    { type: 'infinite_robot_speed', id: 'inf-speed', name: "【限界突破】ロボット速度", baseDesc: "ロボット速度 アップ", count: infiniteRobotSpeedCount }
                ];

                infinites.forEach(inf => {
                    const nextLevel = inf.count + 1;
                    const cost = Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, inf.count));
                    
                    // IDを使って既存の要素を探す
                    const domId = `shop-item-${inf.id}`;
                    let div = document.getElementById(domId);

                    // 存在しない場合のみ新規作成
                    if (!div) {
                        div = document.createElement('div');
                        div.id = domId;
                        div.className = 'upgrade-item';
                        div.innerHTML = `
                            <div class="upgrade-info">
                                <div class="inf-name-display" style="font-weight:bold; font-size:1.1em;"></div>
                                <div style="font-size:0.8em; color:#aaa;">${inf.baseDesc}</div>
                            </div>
                            <div class="action-part">
                                <button class="infinite-buy-btn"></button>
                            </div>
                        `;
                        upgradeListEl.appendChild(div);
                    }

                    // --- 毎回更新する箇所（テキスト、コスト、ボタン状態） ---
                    
                    // レベル表記の更新
                    div.querySelector('.inf-name-display').textContent = `${inf.name} Lv.${nextLevel}`;
                    
                    // ボタンの更新
                    const btn = div.querySelector('button');
                    btn.dataset.type = inf.type;
                    btn.dataset.cost = cost;
                    btn.textContent = `${cost.toLocaleString()} G`;
                    
                    // 購入可否チェック
                    const canBuy = (money >= cost);
                    btn.disabled = !canBuy;
                });
                return; // ページ5の処理はここで終了
            }

            // --- 以下、通常ページ（1〜4）の処理 ---
            const itemsToShow = ALL_UPGRADES.filter(item => item.page === currentShopPage);

            for (let i = 0; i < itemsToShow.length; i++) {
                const item = itemsToShow[i];
                
                // 表示条件チェック
                if (item.reqProgress && cycleCount === 0) {
                    const currentPercent = (cleanedCount / TOTAL_PIXELS) * 100;
                    if (currentPercent < item.reqProgress) {
                        const domId = `shop-item-${item.id}`;
                        const el = document.getElementById(domId);
                        if (el) el.style.display = 'none';
                        continue; 
                    }
                }
                if (item.reqInfinite && !isInfiniteUnlocked) continue;
                if (item.reqPremium && !isPremiumUnlocked) {
                     const domId = `shop-item-${item.id}`;
                     const el = document.getElementById(domId);
                     if (el) el.style.display = 'none';
                     continue;
                }

                let isPurchased = checkPurchased(item);

                // 通常ページのロジック
                if (i > 0) {
                    const prevItem = itemsToShow[i-1];
                    if (!checkPurchased(prevItem)) {
                         const domId = `shop-item-${item.id}`;
                         const el = document.getElementById(domId);
                         if (el) el.style.display = 'none';
                         continue;
                    }
                }

                // DOM作成・表示更新
                const domId = `shop-item-${item.id}`;
                let div = document.getElementById(domId);

                if (!div) {
                    div = document.createElement('div');
                    div.id = domId;
                    div.className = 'upgrade-item';
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'upgrade-info';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.textContent = item.name;
                    const descDiv = document.createElement('div');
                    descDiv.textContent = item.desc;
                    
                    infoDiv.appendChild(nameDiv);
                    infoDiv.appendChild(descDiv);

                    const actionPart = document.createElement('div');
                    actionPart.className = 'action-part';

                    div.appendChild(infoDiv);
                    div.appendChild(actionPart);
                    upgradeListEl.appendChild(div);
                }

                if (isPurchased) {
                    if (!div.classList.contains('purchased')) {
                        div.classList.add('purchased');
                        div.classList.remove('next-up');
                        const actionPart = div.querySelector('.action-part');
                        actionPart.innerHTML = '<div class="status-text">済</div>';
                    }
                } else {
                    if (!div.classList.contains('next-up')) {
                        div.classList.add('next-up');
                        div.classList.remove('purchased');
                        const actionPart = div.querySelector('.action-part');
                        actionPart.innerHTML = `<button data-id="${item.id}">${item.cost.toLocaleString()} G</button>`;
                    } else {
                        const btn = div.querySelector('button');
                        if (btn) {
                            const canBuy = (money >= item.cost);
                            if (btn.disabled === canBuy) { 
                                btn.disabled = !canBuy;
                            }
                        }
                    }
                }
                div.style.display = 'flex'; 
            }
        }

        function onCleanHit(idx) {
            lastCleanTime = Date.now(); 
            if (idx === hintTargetIndex) {
                hintTargetIndex = -1;
                hintBoxEl.style.display = 'none';
            }
        }

        function updateUI() {
            moneyEl.textContent = money.toLocaleString();
            let percentage = (cleanedCount / TOTAL_PIXELS) * 100;

            if (cleanedCount < TOTAL_PIXELS) {
                if (percentage > 99.99) {
                    percentage = 99.99;
                }
            }
            progressEl.textContent = percentage.toFixed(2);
            
            checkVictory(); 
            
            if (cycleCount > 0 || premiumPoints > 0) {
                topLeftInfo.style.display = 'flex';
                const dispNum = (cycleCount + 1).toString().padStart(3, '0');
                cycleCountEl.textContent = dispNum;
                pptValEl.textContent = premiumPoints;

                // ステージ100以上で分母を隠す処理
                const cycleLimitEl = document.querySelector('.cycle-limit');
                if (cycleLimitEl) {
                    if (cycleCount >= 100) {
                        cycleLimitEl.style.display = 'none';
                    } else {
                        cycleLimitEl.style.display = 'inline';
                    }
                }
            }

            if (isZoomUnlocked) {
                zoomIndicator.style.display = 'block';
                zoomValEl.textContent = zoomLevel.toFixed(1);
                resetZoomBtn.style.display = (zoomLevel !== 1.0) ? 'block' : 'none';
            } else {
                zoomIndicator.style.display = 'none';
                resetZoomBtn.style.display = 'none';
            }

            if (isColorPaletteUnlocked) {
                colorPaletteContainer.style.display = 'flex';
            } else {
                colorPaletteContainer.style.display = 'none';
            }

            if (shopModal.style.display === 'flex') {
                updateShopList();
            }

            updateNotification();
            updateGamingLook();

            // ★追加: 連打警告が1回以上ある場合、統計ボタンを赤くする
            if (statSpamWarnings > 0) {
                settingsBtn.style.color = '#ff0000';
                settingsBtn.style.borderColor = '#ff0000'; // 視認性のため枠線も赤くしています
            } else {
                // 通常時（リセット含む）はスタイルを元に戻す
                settingsBtn.style.color = '';
                settingsBtn.style.borderColor = '';
            }
        }

        // ★追加: ロボットにクラスを付与する
        function updateGamingLook() {
            if (isGamingRobotUnlocked) {
                robots.forEach(r => {
                    if (!r.el.classList.contains('gaming')) {
                        r.el.classList.add('gaming');
                    }
                });
            }
        }

        function updateNotification() {
            let hasUpgradeable = false;
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);

            // ページ5（無限強化）のチェック
            if (isInfiniteUnlocked) {
                const costs = [
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteBrushCount)),
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteRobotAreaCount)),
                    Math.floor(INFINITE_BASE_COST * Math.pow(INFINITE_COST_MULT, infiniteRobotSpeedCount))
                ];
                // どれか一つでも買えるなら通知
                if (costs.some(c => money >= c)) {
                    hasUpgradeable = true;
                }
            }

            // 通常ページ（1〜4）のチェック
            if (!hasUpgradeable) {
                for (let page = 1; page <= 4; page++) {
                    const items = ALL_UPGRADES.filter(u => u.page === page);
                    for (let item of items) {
                        if (checkPurchased(item)) continue;
                        
                        if (item.reqProgress && cycleCount === 0) {
                            const currentPercent = (cleanedCount / TOTAL_PIXELS) * 100;
                            if (currentPercent < item.reqProgress) continue;
                        }
                        if (item.reqPremium && !isPremiumUnlocked) continue;
                        if (item.reqInfinite) continue; // infinite系はALL_UPGRADESから削除したのでここは基本通らない

                        if (money >= item.cost) {
                            hasUpgradeable = true;
                            break;
                        }
                    }
                    if (hasUpgradeable) break;
                }
            }

            if (hasUpgradeable) {
                shopBtn.classList.add('has-notification');
            } else {
                shopBtn.classList.remove('has-notification');
            }
        }

        function saveGame() {
            if (isResetting) return;
            showSaveStatus();
            
            const buffer = new Uint8Array(Math.ceil(TOTAL_PIXELS / 8));
            for (let idx of cleanedPixels) {
                const byteIndex = Math.floor(idx / 8);
                const bitIndex = idx % 8;
                buffer[byteIndex] |= (1 << bitIndex);
            }
            let binary = '';
            const len = buffer.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(buffer[i]);
            }
            const pixelData = btoa(binary);

            const robotsData = robots.map(r => ({
                x: r.x, y: r.y, dirX: r.dirX, dirY: r.dirY
            }));

            const saveData = {
                money: money,
                brushLevel: brushLevel,
                isZoomUnlocked: isZoomUnlocked,
                isHintUnlocked: isHintUnlocked,
                robotSpeed: robotSpeed,
                robotBrushLevel: robotBrushLevel, 
                autoClickRate: autoClickRate, 
                currentShopPage: currentShopPage, 
                statTotalClicks: statTotalClicks,
                statClickCleaned: statClickCleaned,
                statRobotCleaned: statRobotCleaned,
                statSpamWarnings: statSpamWarnings,
                cycleCount: cycleCount,
                premiumPoints: premiumPoints,
                isPremiumUnlocked: isPremiumUnlocked,
                isDragCleanUnlocked: isDragCleanUnlocked,
                extraRobotCount: extraRobotCount,
                isInfiniteUnlocked: isInfiniteUnlocked,
                isRobotAIUnlocked: isRobotAIUnlocked,
                isAutoHoverClickUnlocked: isAutoHoverClickUnlocked,
                massProductionCount: massProductionCount,
                infiniteBrushCount: infiniteBrushCount,
                infiniteRobotAreaCount: infiniteRobotAreaCount,
                infiniteRobotSpeedCount: infiniteRobotSpeedCount,
                isPlasmaUnlocked: isPlasmaUnlocked,
                isAutoProgressUnlocked: isAutoProgressUnlocked,
                isPurificationUnlocked: isPurificationUnlocked,
                dirtColor: dirtColor,
                isColorPaletteUnlocked: isColorPaletteUnlocked,
                // ★追加
                isPlasmaBoostUnlocked: isPlasmaBoostUnlocked,
                isGamingRobotUnlocked: isGamingRobotUnlocked,
                isRobotMassProduction5Unlocked: isRobotMassProduction5Unlocked,
                
                robots: robotsData,
                pixels: pixelData
            };

            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (e) {
                console.error("Save failed:", e);
            }
        }

        function loadGame() {
            const json = localStorage.getItem(SAVE_KEY);
            if (!json) return false;

            try {
                const data = JSON.parse(json);
                money = data.money || 0;
                brushLevel = data.brushLevel || 0;
                isZoomUnlocked = data.isZoomUnlocked || false;
                isHintUnlocked = data.isHintUnlocked || false;
                autoClickRate = data.autoClickRate || 0;
                currentShopPage = data.currentShopPage || 1;
                robotSpeed = (data.robotSpeed !== undefined) ? data.robotSpeed : 0.1;
                robotBrushLevel = (data.robotBrushLevel !== undefined) ? data.robotBrushLevel : 0;
                statTotalClicks = data.statTotalClicks || 0;
                statClickCleaned = data.statClickCleaned || 0;
                statRobotCleaned = data.statRobotCleaned || 0;
                statSpamWarnings = data.statSpamWarnings || 0;
                
                cycleCount = data.cycleCount || 0;
                premiumPoints = data.premiumPoints || 0;
                isPremiumUnlocked = data.isPremiumUnlocked || false;
                isDragCleanUnlocked = data.isDragCleanUnlocked || false;

                extraRobotCount = data.extraRobotCount || 0;
                isInfiniteUnlocked = data.isInfiniteUnlocked || false;
                isRobotAIUnlocked = data.isRobotAIUnlocked || false;
                isAutoHoverClickUnlocked = data.isAutoHoverClickUnlocked || false;
                massProductionCount = data.massProductionCount || 0;
                infiniteBrushCount = data.infiniteBrushCount || 0;
                infiniteRobotAreaCount = data.infiniteRobotAreaCount || 0;
                infiniteRobotSpeedCount = data.infiniteRobotSpeedCount || 0;
                
                isPlasmaUnlocked = data.isPlasmaUnlocked || false;
                isAutoProgressUnlocked = data.isAutoProgressUnlocked || false;
                isPurificationUnlocked = data.isPurificationUnlocked || false;

                dirtColor = data.dirtColor || '#87CEEB';
                isColorPaletteUnlocked = data.isColorPaletteUnlocked || false;

                // ★追加: ページ3変数のロード
                isPlasmaBoostUnlocked = data.isPlasmaBoostUnlocked || false;
                isGamingRobotUnlocked = data.isGamingRobotUnlocked || false;
                isRobotMassProduction5Unlocked = data.isRobotMassProduction5Unlocked || false;

                dirtColorPicker.value = dirtColor;
                canvas.style.backgroundColor = dirtColor;

                robots.forEach(r => r.el.remove());
                robots = [];
                if (data.robots && Array.isArray(data.robots)) {
                    data.robots.forEach(r => {
                        let dX = r.dirX;
                        let dY = r.dirY;
                        if (dX === undefined && r.dx !== undefined) dX = Math.sign(r.dx);
                        if (dY === undefined && r.dy !== undefined) dY = Math.sign(r.dy);
                        if (!dX) dX = 1;
                        if (!dY) dY = 1;
                        createRobotEntity(r.x, r.y, dX, dY);
                    });
                }

                if (data.pixels) {
                    cleanedPixels.clear();
                    cleanedCount = 0;
                    const binary = atob(data.pixels);
                    const len = binary.length;

                    ctx.clearRect(0, 0, WIDTH, HEIGHT);
                    ctx.fillStyle = '#000000';

                    for (let i = 0; i < len; i++) {
                        const byte = binary.charCodeAt(i);
                        if (byte === 0) continue;
                        for (let bit = 0; bit < 8; bit++) {
                            if (byte & (1 << bit)) {
                                const idx = i * 8 + bit;
                                cleanedPixels.add(idx);
                                cleanedCount++;
                                const y = Math.floor(idx / WIDTH);
                                const x = idx % WIDTH;
                                ctx.fillRect(x, y, 1, 1);
                            }
                        }
                    }
                } else {
                    ctx.clearRect(0, 0, WIDTH, HEIGHT);
                }

                return true;
            } catch (e) {
                console.error("Load failed:", e);
                return false;
            }
        }

        function showSaveStatus() {
            saveStatusEl.style.opacity = 1;
            setTimeout(() => { saveStatusEl.style.opacity = 0; }, 2000);
        }

        function createRobotEntity(x, y, dirX, dirY) {
            const el = document.createElement('div');
            el.className = 'robot';
            if (isGamingRobotUnlocked) {
                el.classList.add('gaming');
            }
            entityLayer.appendChild(el);
            robots.push({ x: x, y: y, dirX: dirX, dirY: dirY, el: el });
        }

        function addRobot() {
            const x = Math.floor(Math.random() * WIDTH);
            const y = Math.floor(Math.random() * HEIGHT);
            const dirs = [{ dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 }];
            const dir = dirs[Math.floor(Math.random() * dirs.length)];
            createRobotEntity(x, y, dir.dx, dir.dy);
        }

        function buyItem(item) {
            if (money < item.cost) return;

            try {
                // 通常アイテム
                if (item.type === 'brush') {
                    sound.playBuy();
                    money -= item.cost;
                    brushLevel = item.level;
                } else if (item.type === 'zoom') {
                    sound.playBuy();
                    money -= item.cost;
                    isZoomUnlocked = true;
                    alert("ズーム機能が解放されました！");
                } else if (item.type === 'robot') {
                    sound.playBuy();
                    money -= item.cost;
                    addRobot();
                } else if (item.type === 'auto_click') {
                    sound.playBuy();
                    money -= item.cost;
                    autoClickRate = item.rate;
                } else if (item.type === 'robot_area') {
                    sound.playBuy();
                    money -= item.cost;
                    robotBrushLevel = item.level;
                } else if (item.type === 'robot_speed') {
                    sound.playBuy();
                    money -= item.cost;
                    robotSpeed = item.value;
                } else if (item.type === 'hint') {
                    sound.playBuy();
                    money -= item.cost;
                    isHintUnlocked = true;
                    alert("汚染センサーが有効になりました！\n3秒間掃除が行われないと未掃除箇所を強調表示します。");
                } else if (item.type === 'drag_clean') {
                    sound.playBuy();
                    money -= item.cost;
                    isDragCleanUnlocked = true;
                    alert("マジックブラシ解放！\nクリックしたままカーソルを動かすだけで掃除ができます！");
                }
                
                // 無限強化アイテム
                if (item.type === 'infinite_brush') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteBrushCount = item.level;
                } else if (item.type === 'infinite_robot_area') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteRobotAreaCount = item.level;
                } else if (item.type === 'infinite_robot_speed') {
                    sound.playBuy();
                    money -= item.cost;
                    infiniteRobotSpeedCount = item.level;
                }

                updateUI();

            } catch (e) {
                console.error("Purchase error:", e);
            }
        }

        function buyInfiniteItem(type, cost) {
            if (money < cost) return;
            money -= cost;
            
            if (type === 'infinite_brush') infiniteBrushCount++;
            else if (type === 'infinite_robot_area') infiniteRobotAreaCount++;
            else if (type === 'infinite_robot_speed') infiniteRobotSpeedCount++;
            
            updateUI();
        }

        function cleanRobotArea(cx, cy) {
            let pixelsToClean = [];
            let radius = 2 + (robotBrushLevel || 0); 
            
            if (robotBrushLevel >= 4) {
                radius += 2;
            }

            radius += (infiniteRobotAreaCount * 4);

            const r2 = radius * radius;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy <= r2) {
                        pixelsToClean.push({x:dx, y:dy});
                    }
                }
            }

            let earned = 0;
            ctx.fillStyle = '#000000';
            pixelsToClean.forEach(p => {
                const tx = cx + p.x;
                const ty = cy + p.y;
                if (tx>=0 && tx<WIDTH && ty>=0 && ty<HEIGHT) {
                    const idx = ty*WIDTH + tx;
                    if (!cleanedPixels.has(idx)) {
                        ctx.fillRect(tx, ty, 1, 1);
                        cleanedPixels.add(idx);
                        onCleanHit(idx);
                        cleanedCount++;
                        earned++;
                    }
                }
            });
            return earned;
        }

        function updatePlasma() {
            if (!isPlasmaUnlocked || robots.length < 2) return;
            
            const now = Date.now();
            if (now - lastPlasmaTime < 3000) return;
            lastPlasmaTime = now;

            let rBase = 2 + (robotBrushLevel || 0);
            if (robotBrushLevel >= 4) rBase += 2;
            rBase += (infiniteRobotAreaCount * 4);
            const plasmaRadius = Math.max(1, Math.floor(rBase / 2));

            robots.forEach(r1 => {
                // 他の全ロボットとの距離を計算し、近い順（昇順）にソート
                const others = robots.filter(r => r !== r1).map(r => {
                    const distSq = (r.x - r1.x)**2 + (r.y - r1.y)**2;
                    return { r: r, distSq: distSq };
                }).sort((a, b) => a.distSq - b.distSq);

                if (others.length > 0) {
                    // 1. 通常プラズマ: 一番近いロボットへ発射
                    firePlasma(r1, others[0].r, plasmaRadius);
                    
                    // 2. プラズマ強化: 一番遠いロボットへ発射
                    if (isPlasmaBoostUnlocked && others.length > 1) {
                        // 配列の最後（others.length - 1）が一番遠いロボットになります
                        const farthestRobot = others[others.length - 1].r;
                        firePlasma(r1, farthestRobot, plasmaRadius);
                    }
                }
            });
        }

        function firePlasma(r1, r2, radius) {
            // 座標計算
            const dx = r2.x - r1.x;
            const dy = r2.y - r1.y;
            const dist = Math.hypot(dx, dy);
            
            // --- 【改善点1】 描画範囲を少し広げて塗り残しを防ぐ ---
            // 論理的なサイズよりも少しだけ太く描画することで、
            // 「データ上は掃除済みだが、画面が塗られていない」というバグを防ぎます
            ctx.lineCap = 'round';       
            ctx.lineWidth = (radius * 2) + 2;  // +2px 太くする
            ctx.strokeStyle = '#000000'; 
            ctx.beginPath();
            ctx.moveTo(r1.x, r1.y);
            ctx.lineTo(r2.x, r2.y);
            ctx.stroke();

            // --- 【改善点2】 論理計算と補正描画 ---
            // 基本は上のstrokeで塗れていますが、エッジ部分などの微細な塗り漏れを防ぐため、
            // 「今回新しく掃除したピクセル」に限って、念押しでドット描画を行います。
            // ※「新規箇所」だけなので、処理落ちは起きにくい設計です。
            
            const stepSize = Math.max(1, radius / 2); 
            const steps = Math.ceil(dist / stepSize);
            
            let earned = 0;
            const r2Sq = radius * radius;

            // 描画負荷を下げるため、fillStyleの設定はループ外で1回だけ行う
            ctx.fillStyle = '#000000'; 

            for (let i = 0; i <= steps; i++) {
                const t = (steps === 0) ? 0 : i / steps;
                const cx = Math.floor(r1.x + dx * t);
                const cy = Math.floor(r1.y + dy * t);

                for (let py = -radius; py <= radius; py++) {
                    const ty = cy + py;
                    if (ty < 0 || ty >= HEIGHT) continue;

                    for (let px = -radius; px <= radius; px++) {
                        if (px*px + py*py <= r2Sq) {
                            const tx = cx + px;
                            if (tx < 0 || tx >= WIDTH) continue;

                            const idx = ty * WIDTH + tx;
                            
                            // 「まだ掃除されていない場所」だけ処理する
                            if (!cleanedPixels.has(idx)) {
                                cleanedPixels.add(idx);
                                onCleanHit(idx);
                                cleanedCount++;
                                earned++;
                                
                                // ★ここが重要: 
                                // データ更新と同時に、その1点を確実に黒く塗る
                                // (strokeで塗れているはずだが、念のため上書きする)
                                ctx.fillRect(tx, ty, 1, 1);
                            }
                        }
                    }
                }
            }

            if (earned > 0) {
                money += earned;
                statRobotCleaned += earned;
                sound.playClean(); 
            }

            // --- 3. ビジュアルエフェクト (DOM) ---
            const beam = document.createElement('div');
            beam.className = 'plasma-beam';
            
            const screenX1 = r1.x * zoomLevel + panX;
            const screenY1 = r1.y * zoomLevel + panY;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            const screenDist = dist * zoomLevel;
            const screenThickness = (radius * 2) * zoomLevel;

            beam.style.width = `${screenDist}px`;
            beam.style.height = `${Math.max(2, screenThickness)}px`;
            beam.style.left = `${screenX1}px`;
            beam.style.top = `${screenY1 - (Math.max(2, screenThickness)/2)}px`;
            beam.style.transform = `rotate(${angle}deg)`;

            entityLayer.appendChild(beam);

            setTimeout(() => {
                beam.style.opacity = 0;
                setTimeout(() => beam.remove(), 800); 
            }, 100);
            sound.playPlasma(); // ★追加
        }

        function updatePurification() {
            if (!isPurificationUnlocked || hasWon) return;
            if (cleanedCount >= TOTAL_PIXELS) return; 

            if (cleanedCount / TOTAL_PIXELS >= 0.98) {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                for (let i = 0; i < TOTAL_PIXELS; i++) {
                    if (!cleanedPixels.has(i)) {
                        cleanedPixels.add(i);
                    }
                }
                cleanedCount = TOTAL_PIXELS;
                updateUI(); 
            }
        }

        function updateHint() {
            if (!isHintUnlocked) return;
            if (cleanedCount >= TOTAL_PIXELS) {
                 hintBoxEl.style.display = 'none';
                 return;
            }

            if (Date.now() - lastCleanTime > 3000) {
                if (hintTargetIndex === -1) {
                    let startIndex = Math.floor(Math.random() * TOTAL_PIXELS);
                    for (let i = 0; i < TOTAL_PIXELS; i++) {
                        let idx = (startIndex + i) % TOTAL_PIXELS;
                        if (!cleanedPixels.has(idx)) {
                            hintTargetIndex = idx;
                            break;
                        }
                    }
                }

                if (hintTargetIndex !== -1) {
                    const tx = hintTargetIndex % WIDTH;
                    const ty = Math.floor(hintTargetIndex / WIDTH);

                    const size = Math.max(10, 10 * zoomLevel); 
                    const offset = size / 2 - (0.5 * zoomLevel); 
                    
                    const screenX = tx * zoomLevel + panX;
                    const screenY = ty * zoomLevel + panY;

                    hintBoxEl.style.width = `${size}px`;
                    hintBoxEl.style.height = `${size}px`;
                    
                    const centerX = screenX + (0.5 * zoomLevel);
                    const centerY = screenY + (0.5 * zoomLevel);

                    hintBoxEl.style.transform = `translate(${centerX - size/2}px, ${centerY - size/2}px)`;
                    hintBoxEl.style.display = 'block';
                }

            } else {
                hintTargetIndex = -1;
                hintBoxEl.style.display = 'none';
            }
        }

        function updateRobots() {
            let moneyEarnedThisFrame = 0;
            const TARGET_MAG = 1.414; 
            const currentRobotSpeed = robotSpeed + (infiniteRobotSpeedCount * 0.2);

            robots.forEach(robot => {
                robot.x += robot.dirX * currentRobotSpeed;
                robot.y += robot.dirY * currentRobotSpeed;

                let bounced = false;
                
                if (robot.x <= 0) {
                    robot.x = 0;
                    robot.dirX *= -1; 
                    robot.dirY += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                } else if (robot.x >= WIDTH) {
                    robot.x = WIDTH - 0.001;
                    robot.dirX *= -1;
                    robot.dirY += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                }

                if (robot.y <= 0) {
                    robot.y = 0;
                    robot.dirY *= -1; 
                    robot.dirX += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                } else if (robot.y >= HEIGHT) {
                    robot.y = HEIGHT - 0.001;
                    robot.dirY *= -1;
                    robot.dirX += (Math.random() - 0.5) * 0.5;
                    bounced = true;
                }

                if (bounced && isRobotAIUnlocked) {
                    let hasDirtNearby = false;
                    const rCheck = 30;
                    const rCheckSq = rCheck * rCheck;
                    const cx = Math.floor(robot.x);
                    const cy = Math.floor(robot.y);
                    
                    for (let dy = -rCheck; dy <= rCheck; dy += 5) {
                        for (let dx = -rCheck; dx <= rCheck; dx += 5) {
                            if (dx*dx + dy*dy <= rCheckSq) {
                                const tx = cx + dx;
                                const ty = cy + dy;
                                if (tx >= 0 && tx < WIDTH && ty >= 0 && ty < HEIGHT) {
                                    if (!cleanedPixels.has(ty * WIDTH + tx)) {
                                        hasDirtNearby = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (hasDirtNearby) break;
                    }

                    if (!hasDirtNearby) {
                        let minDistSq = Infinity;
                        let targetX = -1;
                        let targetY = -1;

                        const remainingPixels = TOTAL_PIXELS - cleanedCount;
                        const step = (remainingPixels < 2000) ? 1 : 4;
                        
                        for (let y = 0; y < HEIGHT; y += step) {
                            for (let x = 0; x < WIDTH; x += step) {
                                const idx = y * WIDTH + x;
                                if (!cleanedPixels.has(idx)) {
                                    const dx = x - robot.x;
                                    const dy = y - robot.y;
                                    const distSq = dx*dx + dy*dy;
                                    if (distSq < minDistSq) {
                                        minDistSq = distSq;
                                        targetX = x;
                                        targetY = y;
                                    }
                                }
                            }
                        }
                        
                        if (targetX !== -1) {
                            const currentSpeed = Math.hypot(robot.dirX, robot.dirY);
                            if (currentSpeed > 0) {
                                const angle = Math.atan2(targetY - robot.y, targetX - robot.x);
                                robot.dirX = Math.cos(angle) * currentSpeed;
                                robot.dirY = Math.sin(angle) * currentSpeed;
                            }
                        }
                    }
                }

                if (bounced) { 
                    const currentMag = Math.hypot(robot.dirX, robot.dirY);
                    if (currentMag > 0) {
                        if (!isRobotAIUnlocked && currentMag < 0.1) {
                            robot.dirX = (Math.random() > 0.5 ? 1 : -1);
                            robot.dirY = (Math.random() > 0.5 ? 1 : -1);
                        } else {
                            const scale = TARGET_MAG / currentMag;
                            robot.dirX *= scale;
                            robot.dirY *= scale;
                        }
                    }
                }

                const px = Math.floor(robot.x);
                const py = Math.floor(robot.y);

                if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
                    moneyEarnedThisFrame += cleanRobotArea(px, py);
                }
            });
            
            if (moneyEarnedThisFrame > 0) {
                money += moneyEarnedThisFrame;
                statRobotCleaned += moneyEarnedThisFrame;
            }
        }

        function renderEntities() {
            const baseSize = 6; 
            const size = baseSize * zoomLevel;
            const offset = size / 2;

            robots.forEach(robot => {
                const screenX = robot.x * zoomLevel + panX;
                const screenY = robot.y * zoomLevel + panY;
                
                robot.el.style.transform = `translate(${screenX - offset}px, ${screenY - offset}px)`;
                robot.el.style.width = size + 'px';
                robot.el.style.height = size + 'px';
                robot.el.style.borderRadius = '50%';
            });
        }

        function clampPan() {
            const visualWidth = WIDTH * zoomLevel;
            const visualHeight = HEIGHT * zoomLevel;
            const containerW = 1280;
            const containerH = 720;
            if (zoomLevel <= 1.0) { panX = 0; panY = 0; }
            else {
                const minX = containerW - visualWidth;
                const minY = containerH - visualHeight;
                panX = Math.min(0, Math.max(minX, panX));
                panY = Math.min(0, Math.max(minY, panY));
            }
        }

        function applyTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
        }

        function cleanArea(cx, cy) {
            let pixelsToClean = [];
            
            if (brushLevel <= 3) {
                if (brushLevel === 0) pixelsToClean.push({x:0, y:0});
                else if (brushLevel === 1) pixelsToClean.push({x:0,y:0},{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0});
                else if (brushLevel >= 2) {
                    for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) pixelsToClean.push({x:dx,y:dy});
                    if (brushLevel === 3) pixelsToClean.push({x:0,y:-2},{x:0,y:2},{x:-2,y:0},{x:2,y:0});
                }
            } else {
                let radius = 2 + (brushLevel - 3); 
                if (brushLevel >= 9) {
                    radius += 8;
                }

                radius += (infiniteBrushCount * 5);

                const r2 = radius * radius;
                
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx*dx + dy*dy <= r2) {
                            pixelsToClean.push({x:dx, y:dy});
                        }
                    }
                }
            }

            let earned = 0;
            ctx.fillStyle = '#000000';
            pixelsToClean.forEach(p => {
                const tx = cx + p.x;
                const ty = cy + p.y;
                if (tx>=0 && tx<WIDTH && ty>=0 && ty<HEIGHT) {
                    const idx = ty*WIDTH + tx;
                    if (!cleanedPixels.has(idx)) {
                        ctx.fillRect(tx, ty, 1, 1);
                        cleanedPixels.add(idx);
                        onCleanHit(idx); 
                        cleanedCount++;
                        earned++;
                    }
                }
            });
            if (earned > 0) {
                money += earned;
                statClickCleaned += earned; 
            }
        }
        function attemptClean(clientX, clientY) {
            const rect = gameContainer.getBoundingClientRect();
            const relX = clientX - rect.left;
            const relY = clientY - rect.top;
            const canvasX = Math.floor((relX - panX) / zoomLevel);
            const canvasY = Math.floor((relY - panY) / zoomLevel);
            if (canvasX < 0 || canvasX >= WIDTH || canvasY < 0 || canvasY >= HEIGHT) return;
            cleanArea(canvasX, canvasY);
        }

        function startAutoClick() {
        }

        function stopAutoClick() {
        }

        // ===============================================
        //  イベントリスナー・実行 
        // ===============================================

        if (!loadGame()) {
            updateUI();
        } 
        if (robotSpeed === undefined) robotSpeed = 0.1;
        if (robotBrushLevel === undefined) robotBrushLevel = 0;

        requestAnimationFrame(gameLoop);
        setInterval(() => { saveGame(); }, 30000);
        window.addEventListener('beforeunload', () => { saveGame(); });

        shopBtn.addEventListener('click', () => {
            openModal(shopModal);
            updateShopList(true); 
        });
        settingsBtn.addEventListener('click', () => {
            const updateStat = (elementId, value) => {
                const el = document.getElementById(elementId);
                if (el) {
                    el.textContent = value.toLocaleString();
                    el.parentNode.style.display = (value > 0) ? 'block' : 'none';
                }
            };

            updateStat('stat-clicks', statTotalClicks);
            updateStat('stat-click-cleaned', statClickCleaned);
            updateStat('stat-robot-cleaned', statRobotCleaned);
            updateStat('stat-spam-warnings', statSpamWarnings);
            
            openModal(settingsModal);
        });

        // プレミアム関連イベント
        premiumBtn.addEventListener('click', () => {
            updatePremiumShop();
            openModal(premiumModal);
        });

        function updatePremiumShop() {
            modalPptValEl.textContent = premiumPoints;
            premiumListEl.innerHTML = '';

            // ★変更: ページ3の解放条件判定
            // ページ2の完了条件: ロボット量産(Lv3) + プラズマ + 自動進行 + 浄化 + カラーパレット
            const isPage2Complete = (massProductionCount >= 3 && isPlasmaUnlocked && isAutoProgressUnlocked && isPurificationUnlocked && isColorPaletteUnlocked);
            
            // maxPageの計算
            let maxPage = 1;
            if (isAutoHoverClickUnlocked) maxPage = 2; // クリック代行でページ2解放
            if (isPage2Complete) maxPage = 3;          // ページ2コンプでページ3解放

            premiumPageNumEl.textContent = currentPremiumPage;
            premiumPageMaxEl.textContent = maxPage;

            if (maxPage > 1) {
                premiumPagination.style.display = 'flex';
                prevPremiumPageBtn.disabled = (currentPremiumPage <= 1);
                nextPremiumPageBtn.disabled = (currentPremiumPage >= maxPage);
            } else {
                premiumPagination.style.display = 'none';
            }

            const itemsToShow = PREMIUM_UPGRADES.filter(item => item.page === currentPremiumPage);

            itemsToShow.forEach(item => {
                // 既存の解放条件
                if (item.reqRobotMax && extraRobotCount < 3) return;
                if (item.reqAI && !isRobotAIUnlocked) return;
                if (item.reqMassProductionMax && massProductionCount < 3) return; 

                const div = document.createElement('div');
                div.className = 'premium-item';
                
                let isPurchased = false;
                let cost = 0;
                let btnText = "";
                let disabled = false;

                // IDごとの処理...
                if (item.id === 'p1') {
                    isPurchased = isPremiumUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p2') { 
                    cost = Math.pow(2, extraRobotCount);
                    isPurchased = (extraRobotCount >= 3); 
                    btnText = isPurchased ? "完売" : `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true; 
                } else if (item.id === 'p3') { 
                    isPurchased = isInfiniteUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true; 
                } else if (item.id === 'p4') {
                    isPurchased = isRobotAIUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true;
                } else if (item.id === 'p5') {
                    isPurchased = isAutoHoverClickUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                    if (!isPremiumUnlocked) disabled = true;
                } else if (item.id === 'p6') {
                    const costs = [4, 6, 8];
                    if (massProductionCount < 3) {
                        cost = costs[massProductionCount];
                        btnText = `${cost} Pt`;
                    } else {
                        isPurchased = true;
                        btnText = "完売";
                    }
                } else if (item.id === 'p7') { 
                    isPurchased = isPlasmaUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p8') {
                    isPurchased = isAutoProgressUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p9') { 
                    isPurchased = isPurificationUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                } else if (item.id === 'p10') { 
                    isPurchased = isColorPaletteUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                // ★追加: ページ3のアイテム処理
                else if (item.id === 'p11') { // プラズマ強化
                    isPurchased = isPlasmaBoostUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                else if (item.id === 'p12') { // ロボット大量生産
                    isPurchased = isRobotMassProduction5Unlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }
                else if (item.id === 'p13') { // ゲーミングロボット
                    isPurchased = isGamingRobotUnlocked;
                    cost = item.costPt;
                    btnText = `${cost} Pt`;
                }

                let btnHtml = '';
                if (isPurchased) {
                    div.classList.add('purchased');
                    btnHtml = '<div>済</div>';
                } else {
                    const canBuy = (premiumPoints >= cost) && !disabled;
                    const disabledAttr = canBuy ? '' : 'disabled';
                    btnHtml = `<button onclick="buyPremiumItem('${item.id}')" ${disabledAttr}>${btnText}</button>`;
                }

                div.innerHTML = `
                    <div class="upgrade-info">
                        <div>${item.name}</div>
                        <div style="font-size:0.8em; color:#ccc;">${item.desc}</div>
                    </div>
                    <div class="action-part">${btnHtml}</div>
                `;
                premiumListEl.appendChild(div);
            });
        }
        window.buyPremiumItem = function(id) {
            const item = PREMIUM_UPGRADES.find(i => i.id === id);
            if (!item) return;

            let cost = 0;
            if (id === 'p1') cost = item.costPt;
            else if (id === 'p2') cost = Math.pow(2, extraRobotCount);
            else if (id === 'p3') cost = item.costPt;
            else if (id === 'p4') cost = item.costPt;
            else if (id === 'p5') cost = item.costPt;
            else if (id === 'p6') {
                const costs = [4, 6, 8];
                cost = costs[massProductionCount];
            } else if (id === 'p7') cost = item.costPt;
            else if (id === 'p8') cost = item.costPt;
            else if (id === 'p9') cost = item.costPt;
            else if (id === 'p10') cost = item.costPt;
            // ★追加
            else if (id === 'p11') cost = item.costPt;
            else if (id === 'p12') cost = item.costPt;
            else if (id === 'p13') cost = item.costPt;

            if (premiumPoints < cost) return;

            if (id === 'p1') {
                premiumPoints -= cost;
                isPremiumUnlocked = true;
                alert("プレミアムコース解放！\n通常ショップに強力なアイテムが追加されました。");
            } else if (id === 'p2') {
                if (extraRobotCount >= 3) return;
                premiumPoints -= cost;
                extraRobotCount++;
                addRobot(); 
            } else if (id === 'p3') {
                premiumPoints -= cost;
                isInfiniteUnlocked = true;
                alert("限界突破！\nショップに「ページ5」が追加されました。");
            } else if (id === 'p4') {
                premiumPoints -= cost;
                isRobotAIUnlocked = true;
                alert("お掃除AI搭載完了！");
            } else if (id === 'p5') {
                premiumPoints -= cost;
                isAutoHoverClickUnlocked = true;
                alert("クリック代行システム起動！\nこれよりプレミアムショップのページ2が解放されます。");
            } else if (id === 'p6') {
                if (massProductionCount >= 3) return;
                premiumPoints -= cost;
                massProductionCount++;
                addRobot(); 
                addRobot(); 
                alert(`ロボット部隊到着！\n現在の生産レベル: ${massProductionCount}/3`);
            } else if (id === 'p7') {
                premiumPoints -= cost;
                isPlasmaUnlocked = true;
                alert("プラズマシステム起動！\nロボット同士が連携して汚れを焼き払います！");
            } else if (id === 'p8') {
                premiumPoints -= cost;
                isAutoProgressUnlocked = true;
                alert("自動進行モードON\nクリア画面が自動的にスキップされるようになります。");
            } else if (id === 'p9') {
                premiumPoints -= cost;
                isPurificationUnlocked = true;
                alert("浄化システム起動！\n進行率98%で残りの汚れを消滅させます。");
            } else if (id === 'p10') {
                premiumPoints -= cost;
                isColorPaletteUnlocked = true;
                alert("カラーパレット解放！\n画面右下から汚れの色を変更できます。");
            }
            // ★追加: ページ3の購入処理
            else if (id === 'p11') {
                premiumPoints -= cost;
                isPlasmaBoostUnlocked = true;
                alert("プラズマ出力強化！\n3体以上のロボットがいる場合、2本のビームで連携します！");
            }
            else if (id === 'p12') {
                premiumPoints -= cost;
                isRobotMassProduction5Unlocked = true;
                // 一気に5体追加
                for(let k=0; k<5; k++) addRobot();
                alert("大規模増産完了！\nロボットが5体追加されました！");
            }
            else if (id === 'p13') {
                premiumPoints -= cost;
                isGamingRobotUnlocked = true;
                updateGamingLook(); // 即座に見た目を反映
                alert("ゲーミングモードON！\nロボットが七色に輝き始めました！");
            }

            updatePremiumShop();
            updateUI();
            saveGame();
        };

        closeModalBtns.forEach(btn => {
            btn.addEventListener('click', closeAllModals);
        });
        overlay.addEventListener('click', closeAllModals);

        resetDataBtn.addEventListener('click', () => {
            if (confirm("本当にデータを削除しますか？\nこの操作は取り消せません。")) {
                isResetting = true;
                localStorage.removeItem(SAVE_KEY);
                location.reload();
            }
        });
        
        resetZoomBtn.addEventListener('click', () => {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            applyTransform();
            updateUI();
        });

        prevPageBtn.addEventListener('click', () => {
            if (currentShopPage > 1) {
                upgradeListEl.innerHTML = ''; 
                currentShopPage--;
                updateShopList(true);
            }
        });
        nextPageBtn.addEventListener('click', () => {
            const maxPage = isInfiniteUnlocked ? 5 : ((robots.length > 0) ? 4 : 1);
            if (currentShopPage < maxPage) {
                upgradeListEl.innerHTML = ''; 
                currentShopPage++;
                updateShopList(true);
            }
        });

        upgradeListEl.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                // ★追加: 無限強化ボタンの判定
                if (e.target.classList.contains('infinite-buy-btn')) {
                    const type = e.target.dataset.type;
                    const cost = parseInt(e.target.dataset.cost);
                    buyInfiniteItem(type, cost);
                    return;
                }
                
                // 通常アイテムの判定
                const id = parseInt(e.target.dataset.id);
                if (!isNaN(id)) {
                    const item = ALL_UPGRADES.find(u => u.id === id);
                    if (item) buyItem(item);
                }
            }
        });

        gameContainer.addEventListener('mousedown', (e) => {
            if (overlay.style.display === 'block') return;
            if (e.button === 2 && isZoomUnlocked) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'move';
                return;
            }
            if (e.button === 0) {
                isMouseDown = true;
                currentSecondClicks++;
                statTotalClicks++;
                
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                attemptClean(e.clientX, e.clientY);
                
                if (autoClickRate > 0) startAutoClick();
            }
        });

        gameContainer.addEventListener('mousemove', (e) => {
            currentMouseX = e.clientX;
            currentMouseY = e.clientY;
            
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx;
                panY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                clampPan();
                applyTransform();
                return;
            }

            if (isAutoHoverClickUnlocked && !isMouseDown) {
                isMouseDown = true;
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                if (autoClickRate > 0) startAutoClick();
            }

            if (isMouseDown && isDragCleanUnlocked) {
                const dx = e.clientX - lastCleanX;
                const dy = e.clientY - lastCleanY;
                const dist = Math.hypot(dx, dy);
                
                const steps = Math.ceil(dist);
                
                for (let i = 0; i <= steps; i++) {
                    const t = (steps === 0) ? 1 : i / steps;
                    const interpX = lastCleanX + dx * t;
                    const interpY = lastCleanY + dy * t;
                    attemptClean(interpX, interpY);
                }

                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
            }
        });

        gameContainer.addEventListener('mouseup', (e) => {
            if (e.button === 0) { 
                if (!isAutoHoverClickUnlocked) {
                    isMouseDown = false; 
                    stopAutoClick(); 
                }
            }
            if (isDragging) { isDragging = false; canvas.style.cursor = 'crosshair'; }
        });

        gameContainer.addEventListener('mouseleave', (e) => {
            isMouseDown = false;
            stopAutoClick();
            if (isDragging) { isDragging = false; canvas.style.cursor = 'crosshair'; }
        });

        gameContainer.addEventListener('wheel', (e) => {
            if (!isZoomUnlocked) return;
            e.preventDefault();
            const rect = gameContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldX = (mouseX - panX) / zoomLevel;
            const worldY = (mouseY - panY) / zoomLevel;
            const delta = -Math.sign(e.deltaY) * 0.1;
            let newZoom = zoomLevel + delta;
            newZoom = Math.max(1.0, Math.min(3.0, newZoom));
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                panX = mouseX - worldX * zoomLevel;
                panY = mouseY - worldY * zoomLevel;
                clampPan();
                applyTransform();
                updateUI();
            }
        }, { passive: false });

        gameContainer.addEventListener('contextmenu', (e) => e.preventDefault());

        gameContainer.addEventListener('mouseenter', (e) => {
            if (isAutoHoverClickUnlocked) {
                isMouseDown = true;
                lastCleanX = e.clientX;
                lastCleanY = e.clientY;
                if (autoClickRate > 0) startAutoClick();
            }
        });
       

        const victoryModal = document.getElementById('victory-modal');
        const autoProgressMsg = document.getElementById('auto-progress-msg');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiAnimId = null;
        let particles = [];

        function resizeConfetti() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeConfetti);

        class Particle {
            constructor() {
                this.x = Math.random() * confettiCanvas.width;
                this.y = Math.random() * confettiCanvas.height - confettiCanvas.height;
                this.size = Math.random() * 10 + 5;
                this.speedY = Math.random() * 3 + 2;
                this.speedX = Math.random() * 2 - 1;
                this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = Math.random() * 10 - 5;
            }
            update() {
                this.y += this.speedY;
                this.x += this.speedX;
                this.rotation += this.rotationSpeed;
                if (this.y > confettiCanvas.height) {
                    this.y = -10;
                    this.x = Math.random() * confettiCanvas.width;
                }
            }
            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate(this.rotation * Math.PI / 180);
                confettiCtx.fillStyle = this.color;
                confettiCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                confettiCtx.restore();
            }
        }

        function startConfetti() {
            resizeConfetti();
            particles = [];
            for (let i = 0; i < 150; i++) { 
                particles.push(new Particle());
            }
            animateConfetti();
        }

        function animateConfetti() {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            confettiAnimId = requestAnimationFrame(animateConfetti);
        }

        function stopConfetti() {
            if (confettiAnimId) cancelAnimationFrame(confettiAnimId);
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        }

        function checkVictory() {
            if (hasWon) return; 
            
            if (cleanedCount >= TOTAL_PIXELS) {
                hasWon = true;
                sound.playVictory();
                
                // 要素の取得
                const h1 = victoryModal.querySelector('h1');
                const pSub = victoryModal.querySelector('.victory-content p'); // "CLICK TO CLOSE"の部分
                const msg = document.getElementById('auto-progress-msg');

                // ★ステージ100 (cycleCount 99) クリア時の特別演出
                if (cycleCount === 99) {
                    victoryModal.style.display = 'flex';
                    
                    // テキストとスタイルを豪華版に変更
                    h1.textContent = "GAME CLEAR!!";
                    h1.className = "blink-text true-ending-title"; // 豪華CSSクラスを適用
                    
                    pSub.textContent = "THANK YOU FOR PLAYING";
                    pSub.className = "true-ending-sub";

                    // 紙吹雪開始
                    startConfetti();

                    // ★重要: 自動進行を強制的に無効化（メッセージも非表示）
                    msg.style.display = 'none';

                    // ここで処理を終了し、ユーザーのクリックを待つ
                    return;
                }

                // --- 通常のクリア処理 ---
                victoryModal.style.display = 'flex';
                
                // 通常スタイルに戻す（リセット）
                h1.textContent = "CONGRATULATIONS";
                h1.className = "blink-text"; 
                pSub.textContent = "CLICK TO CLOSE";
                pSub.className = "";

                startConfetti();

                if (isAutoProgressUnlocked) {
                    msg.style.display = 'block';
                    setTimeout(() => {
                        // モーダルがまだ開いていれば自動で閉じる
                        if (victoryModal.style.display !== 'none') {
                            victoryModal.style.display = 'none';
                            stopConfetti();
                            resetBoard();
                        }
                    }, 1000);
                } else {
                    msg.style.display = 'none';
                }
            }
        }

        victoryModal.addEventListener('click', () => {
            victoryModal.style.display = 'none';
            stopConfetti();
            resetBoard();
        });

        prevPremiumPageBtn.addEventListener('click', () => {
            if (currentPremiumPage > 1) {
                currentPremiumPage--;
                updatePremiumShop();
            }
        });
        
        nextPremiumPageBtn.addEventListener('click', () => {
            const isPage2Complete = (massProductionCount >= 3 && isPlasmaUnlocked && isAutoProgressUnlocked && isPurificationUnlocked && isColorPaletteUnlocked);
            let maxPage = 1;
            if (isAutoHoverClickUnlocked) maxPage = 2;
            if (isPage2Complete) maxPage = 3;

            if (currentPremiumPage < maxPage) {
                currentPremiumPage++;
                updatePremiumShop();
            }
        });
        
        premiumBtn.addEventListener('click', () => {
            updatePremiumShop();
            openModal(premiumModal);
        });

        dirtColorPicker.addEventListener('input', (e) => {
            if (!isColorPaletteUnlocked) return;
            dirtColor = e.target.value;
            canvas.style.backgroundColor = dirtColor;
        });

        function redrawBoard() {
            ctx.fillStyle = dirtColor;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = '#000000';
            cleanedPixels.forEach(idx => {
                const y = Math.floor(idx / WIDTH);
                const x = idx % WIDTH;
                ctx.fillRect(x, y, 1, 1);
            });
        }

        function resetBoard() {
            cycleCount++;
            premiumPoints++; 
            
            cleanedCount = 0;
            cleanedPixels.clear();
            hasWon = false;

            canvas.style.backgroundColor = dirtColor; 
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            hintBoxEl.style.display = 'none';
            hintTargetIndex = -1;

            updateUI();
            
            cycleCountEl.classList.remove('flash-active');
            void cycleCountEl.offsetWidth; 
            cycleCountEl.classList.add('flash-active');
            
            saveGame();
        }

        const soundBtn = document.getElementById('sound-toggle-btn');
        soundBtn.addEventListener('click', () => {
            const isEnabled = sound.toggle();
            soundBtn.textContent = isEnabled ? "SOUND: ON" : "SOUND: OFF";
            soundBtn.style.color = isEnabled ? "#0f0" : "#fff";
            soundBtn.style.borderColor = isEnabled ? "#0f0" : "#fff";
        });

        function gameLoop(timestamp) {
		    // 初回実行時の時間調整
		    if (!lastFrameTime) lastFrameTime = timestamp;
		    
		    // 前回のフレームからの経過時間（秒）を計算
		    const deltaTime = (timestamp - lastFrameTime) / 1000;
		    lastFrameTime = timestamp;

		    updateRobots();
		    updatePlasma(); 
		    updatePurification(); 
		    renderEntities();
		    updateHint();

		    // --- 自動クリック処理の最適化版 ---
		    if (isMouseDown && autoClickRate > 0) {
		        // 経過時間 × 速度 分のクリック回数を貯める
		        autoClickAccumulator += autoClickRate * deltaTime;

		        // 1回分以上貯まっていたら実行
		        // ※「マウス位置が変わっていないのに何度も描画する」無駄を防ぐため、
		        //   ループはさせず、貯まっている分を1回だけ実行して消費します。
		        //   （このゲームの仕様上、同じ場所を連打しても意味がないためこれで軽量化されます）
		        if (autoClickAccumulator >= 1) {
		            attemptClean(currentMouseX, currentMouseY);
		            
		            // 貯まった分を消費（余剰分は次回に持ち越し）
		            // ただし、極端に溜まりすぎた場合（ラグなど）はリセットしてフリーズを防ぐ
		            if (autoClickAccumulator > 5) {
		                 autoClickAccumulator = 0;
		            } else {
		                 autoClickAccumulator -= 1;
		            }
		        }
		    } else {
		        // クリックしていない時はリセット
		        autoClickAccumulator = 0;
		    }
		    // ----------------------------------
		    
		    if (timestamp - lastUIUpdate > 33) {
		        updateUI();
		        lastUIUpdate = timestamp;
		    }
		    requestAnimationFrame(gameLoop);
		}
    </script>
</body>
</html>